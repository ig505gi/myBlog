{"pages":[],"posts":[{"title":"JavaScript高级程序设计","text":"Chapter 1-7 JS的基础知识1 JS的历史 JS包括ECMA、DOM、BOM… 2 HTML HTML的发展，HTML中如何用JS… 3 语法 Number类型的上下限…4 变量、作用域 执行环境是什么，「没有块级作用域」 垃圾回收、接触引用 5 引用类型6 面向对象 设计模式：工厂模式、继承模式 原型链 7 私有变量 闭包 模仿块级作用域 模块模式 &amp; 单例模式 Chapter 8 BOM1 window对象 frame框架，每一层都有个window对象，top指向最高层级的window 窗口位置 窗口大小 导航和打开窗口 间歇调用和超时调用(setTimeout/setInterval) 系统对话框(alert/prompt/confirm/print/find) 2 location对象 既是windows的对象，又是document的对象 location的属性： 每次修改location的属性(hash除外)页面都会以新url重新加载 replace方法不能生成历史记录，也不能返回刚刚的网页 3 navigator对象 有属性浏览器版本信息、名称、插件、环境等 注册处理程序registerContentHandler()和registerProtocolHandler()方法，跟RSS和在线电子邮件有关 4 screen对象能够拿到一些屏幕的硬件信息：PPI、像素、刷新率等，对于编程意义不大 5 history对象安全的：开发者是不能知道用户访问过那些网页的方法：go/back/forward Chapter 10-12 DOMDOM（文档对象类型）是针对HTML和XML文档的一个API。DOM 可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型。如下多种： 1 节点层次1.1 Node类型 其它节点都继承自Node类型，每个节点都有一个nodeType的属性，记录了其类型 每个节点都有这样或那样的关系。每个节点都有一个childNodes属性，其中保存着一个NodeList对象 每个节点都有一个parentNode属性，该属性指向文档树中的父节点 常用方法appendChild()。用于向childNodes列表的末尾添加一个节点。 常用方法insertBefore()。这个方法接受两个参数:要插入的节点和作为参照的节点。 常用方法replaceChild()。这个方法接受两个参数:要插入的节点和要替换的节点。 其他方法cloneNode()可以深浅复制；normalize()处理文档树中的文本节点。1.2 Document类型 document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面。 document对象是Window对象的一个属性，可以将其作为全局属性访问。 document对象的属性nodeType值为9。 document对象的属性documentElement、firstChild和childNodes[0]的值相同，都指向&lt;html&gt;元素。 document作为HTMLDocument实例，有一些不同于Document类型的属性：title、URL、domain、referrer。其中title和domain是可以设置的，domain只能修改三级域名(www) Document类型都有的方法：getElementById()和getElementsByTagName();HTMLDocument类型独有的方法是getElementsByName()。 document有一些集合可以方便拿到一些HTMLCollection：document.links拿到所有带href的&lt;a&gt;元素、document.forms拿到所有&lt;form&gt;元素、document.images拿到所有&lt;img&gt;元素 document.implementation.hasFeature(&quot;XML&quot;, &quot;1.0&quot;) 可以检测DOM的功能及版本号 document对象具有输出流写入网页的功能：write()、writeln()、open()、close()1.3 Element类型 所有的HTML元素都是HTMLElement类型，其继承自Element类型，添加了一些Element没有的属性：id、titile、className等；可以直接像这样div.id通过属性访问对其属性赋值和取值 getAttribute()、setAttribute()、removeAttribute()是三个常用的方法 H5规范规定，自定义特性需要有data-前缀；通过getAttribute方法可以拿到自定义特性的值；除了IE可以直接用div.myAttr这样通过属性访问拿到特性的值，其他浏览器都不可以 style属性：通过getAttribute方法拿到的是CSS文本，通过属性访问拿到的是对象 onClick属性：通过getAttribute方法拿到的是响应代码的字符串，通过属性访问拿到的是JS函数 通过setAttribute()方法设置的特性，统一会变成小写 想要遍历元素的特性，可以使用attributes属性element.attributes var div = document.createElement(&quot;div&quot;);1.4 Text类型 文本节点，parentNode是一个Element类型；通过nodeValue属性或data属性访问文本内容，是一致的 常用方法：appendData() deleteData() insertData() replaceData() splitText() substringData() div.firstChild.nodeValue = 'aa&lt;s&gt;'; 输出的结果是转义过的，是aa&amp;lt;s&amp;gt; document.createTextNode()创建新文本节点，但是如果不指定其父元素，在页面上是看不到的； 1.5-1.9 其它类型 Comment类型：parentNode可能是Document或Element类型；有除了splitText以外的Text类型的全部方法 CDATASection：类型只针对基于XML的文档 DocumentType类型：在Web浏览器中并不常用，仅有 Firefox、Safari 和 Opera 支持它 DocumentFragment类型：只有它在文档中没有对应的标记，可以当做一个仓库。比如如果向文档中渲染三个连续的元素，先放到仓库里，可以避免重复渲染三次 Attr类型：不是DOM文档树的一部分，是元素的特性 2 DOM扩展2.1 选择符API querySelector() querySelectorAll() msMatchesSelector() … 3 DOM2和DOM3DOM1主要定义的是HTML和XML文档的底层结构 DOM2的模块 DOM2级核心(DOM Level 2 Core):在1级核心基础上构建，为节点添加了更多方法和属性。 DOM2级视图(DOM Level 2 Views):为文档定义了基于样式信息的不同视图。 DOM2级事件(DOM Level 2 Events):说明了如何使用事件与 DOM 文档交互。 DOM2级样式(DOM Level 2 Style):定义了如何以编程方式来访问和改变 CSS 样式信息。 DOM2级遍历和范围(DOM Level 2 Traversal and Range):引入了遍历 DOM 文档和选择其特定部分的新接口。 DOM2级HTML(DOM Level 2 HTML):在1级HTML基础上构建，添加了更多属性、方法和新接口。 … Chapter 13 事件JS和HTML之间的交互是通过事件实现的。","link":"/myBlog/2022/03/21/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"title":"Effective javascript","text":"chapter1 让自己习惯JavaScript1.ES版本问题及strict modeES5引入了严格模式，使用字符串字面量作为指令是为了向前兼容，ES3看到&quot;use strict&quot;会直接丢掉。为了解决严格模式和非严格模式的文件打包在一起的问题，可以用IIFE(Immmediately Invoked Function Expression)来解决 2.number是浮点型JS中的数字只有number一种类型，是符合IEEE754制定的64位编码数字—-doublesnumber的位运算会隐式地转为32位整数，然后计算。 3. 当心隐式的强制转换很多JS代码不会报错，而是会做强制的转换 123453 + true // 4&quot;hello&quot; + &quot; world&quot; // &quot;hello world&quot;2 + &quot;3&quot; // &quot;23&quot;&quot;17&quot; * &quot;5&quot; // 85&quot;8&quot; | &quot;1&quot; // 9 尽量避免使用valueOf() 3.1 真值运算(truthines)JS有7个假值：false/0/-0/&quot;&quot;/null/NaN/undefined 4.原始类型优于封装对象JS的5个原始类型boolean/number/string/null/undefined 封装对象的方法，原始类型也可以使用，例如toUpperCase是String的原型对象的方法，而原始字符串可以直接调用：&quot;hello&quot;.toUpperCase(); // &quot;HELLO&quot;这种隐式封装，每次调用都会产生一个新的String对象，因此对其设置属性是不起作用的。 5.避免对混合类型使用==运算符当两个参数属于同一类型时，==和===是没有区别的当使用==对不同的类型比较时，有强制类型转换规则，记忆比较麻烦，因此最好避免 6.了解分号插入的局限JS有自动分号插入技术，因此不用写分号。分号插入的规则： 分号仅在}标记之前、一个或多个换行之后和程序输入的结尾被插入 分号仅在随后的输入标记不能解析时插入 7.视字符串为16位的代码单元序列因此，一个以上的音乐符号，在字符串中的长度是2 1234&quot;∮ clef&quot;.charCodeAt(0); // 55348(0xd834)&quot;∮ clef&quot;.charCodeAt(0); // 56606(0xdd1e)&quot;∮ clef&quot;.charAt(1) === &quot; &quot;; // false&quot;∮ clef&quot;.charAt(2) === &quot; &quot;; // true chapter2 变量作用域8.尽量少用全局对象简单理解：容易冲突 9.始终声明局部变量虽然js不声明变量不会报错，但是这个变量直接变成了全局变量，要避免 10.避免使用withwith可以避免对对象的重复引用，但是不可靠性大大增加，避免使用 11.熟练掌握闭包事实1. JS允许你引用在当前函数以外定义的变量事实2. 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量事实3. 闭包可以更新外部的值 原理:JS的函数值在内部存储它们可能会引用的定义在其封闭作用域的变量。 12345678910111213function box() { var val = undefined; return { set: function(newVal) { val = newVal; }, get: function() { return val; }, type: function() { return typeof val; } }}var v = box();b.type(); // &quot;undefined&quot;b.set(98.6);b.get(); // 98.6b.type(); // &quot;number&quot; 这基本就是一个Class了，ES6的Class编译之后好像就是这样？ 12.理解变量声明提升JS不支持块级作用域，而是函数级作用域变量提升： 1234567891011121314151617181920function f() { // ... { // ... var x=/*...*/; // ... } // ...}// 会转化为以下：function f() { var x; // ... { // ... x=/*...*/; // ... } // ...} 异常处理的catch看似块级作用域，但是感觉更像函数，因此是个例外 13.使用立即调用的函数表达式创建局部作用域闭包通过引用而不是值捕获它们的外部变量 好好理解下面三段代码： 12345678910function wrapElements(a) { var result = [], i, n; for(i = 0, n = a.length; i &lt; n; i++) { result[i] = function() { return a[i]; }; } return result;}var wrapped = wrapElements([10, 20, 30]);var f = wrapped[0];f(); // undefined 12345678910function wrapElements(a) { var result = []; for(var i = 0, n = a.length; i &lt; n; i++) { result[i] = function() { return a[i]; }; } return result;}var wrapped = wrapElements([10, 20, 30]);var f = wrapped[0];f(); // undefined 这个版本更具有欺骗性，但是由于变量提升，没有块级作用域，i仍然只有一个槽(slot)想实现的效果： 12345678910111213function wrapElements(a) { var result = [], i, n; for(i = 0, n = a.length; i &lt; n; i++) { (function() { var j = i; result[i] = function() { return a[j]; }; })() } return result;}var wrapped = wrapElements([10, 20, 30]);var f = wrapped[0];f(); // 10 14.当心命名函数表达式笨拙的作用域123456var f = function abs(a) { return a &lt; 0 ? -a : a;}f(-2); // 2abs(-3); // wrong 并没有abs这个变量// 但是有些JS环境会产生abs，甚至分配多余的内存，都是不符合规范的 命名函数表达式的作用域在E3中会表示为一个对象，从而导致跟with语句一样的问题，作用域会受到Object.prototype的属性变化。在E5中修复了这个问题 15.当心局部块函数生命笨拙的作用域函数中可以嵌套函数，但是如果再把函数声明放在if语句块中呢？在不同的JS运行环境中，可能有不同的解释，因此避免使用 16.避免使用eval创建局部变量eval很强大，但使用起来有安全性，避免如下使用方式： 123456function test(src) { eval(src); return y;}test(&quot;var y = 'local';&quot;); 推荐如下，这样不会对函数内部造成影响： 123456function test(src) { (function() {eval(src);})() return y;}test(&quot;var y = 'local';&quot;); 17.间接调用eval函数优于直接调用大多数函数只能访问定义它们所在的作用域，而eval函数具有访问调用它那时的整个作用域的能力。 （有点绕） 直接调用和间接调用： 123456var x = 'global';function test() { var x = 'local'; return eval(&quot;x&quot;); // 直接调用}test(); // &quot;local&quot; 1234567var x = 'global';function test() { var x = 'local'; var f = eval; return f(&quot;x&quot;); // 间接调用}test(); // &quot;local&quot; 例子是有了，但是不太明白为什么后者优于前者 间接调用还有另外一种方式(0, eval)(src) chapter3 使用函数18.理解函数调用、方法调用及构造函数调用在面向对象中，三种概念是不同的。但是在JS中，只是单个构造对象的不同使用模式。方法就是特定对象调用的函数如果纯函数中使用this，会默认使用全局对象，但ES5中规定的严格模式不会这么做，会报错。纯函数作为构造函数使用： 12345678function User(name, age) { this.name = name; this.age = age;}// 用new操作符能识别构造函数const person = new User('Jack', 18);person.name; // 'Jack' 19. 熟练掌握高阶函数 高阶函数是那些将函数作为参数或返回值的函数 熟悉掌握现有库中的高阶函数 学会发现可以被高阶函数所取代的常见的编码模式 20. 使用call方法来自定义接收者来调用方法需要自定义接收者来调用函数时，也就是说想改变函数中的this 12345// 不推荐的方法：obj.temp = f;f(arg1, arg2);delete obj.temp// 万一obj就有temp呢？ call方法支持传入一个接收者来调用函数，相当于改变了this 21. 使用apply方法通过不同数量的参数调用函数当一个函数可接受可变参数时，用apply传入数组 123var scores = getAllScores(); // 返回一个数组// average可接受可变参数average.apply(null, scores); 22. 使用arguments创建可变参数的函数如果提供一个便利的可变参数的函数，同时最好提供一个需要显式指定数组的固定参数版本，很容易实现： 1234function average() { // average可接受可变参数 averageOfArray(arguments);} 23. 永远不要修改arguments对象如下实现： 12345678910function callMethod(obj, method) { var args = [].slice.call(arguments, 2); retrun obj[method].apply(obj, args);}var obj = { add: function(x + y) { return x + y; }}callMethod(obj, 'add', 17, 25); 24.使用变量保存arguments对象的引用主要是注意函数嵌套时，arguments会变，要用外层的arguments时，需要先保存引用 25.使用bind方法提取具有确定接收者的方法12345678910111213141516var buffer = { entries: [], add: function(s) { this.entries.push(s); }}// wrongvar source = [1, 2, 3];source.forEach(buffer.add); // entries undefined// correctsource.forEach(buffer.add.bind(buffer));// 注意！！buffer.add === buffer.add.bind(buffer); // false bind是安全的，不会修改add方法，bind方法创建了一个新的方法，里面this指向的buffer 26.使用bind函数进行函数柯里化1234567891011function simpleURL(protocol, domain, path) { return protocol + '://' + domin + '/' + path;}//优化前var urls = paths.map(function(path) { return simpleURL('http', siteDomain, path);})// 优化后var urls = paths.map(simpleURL.bind(null, 'http', siteDomain)); 27.使用闭包而不是字符串封装代码这个正常人也不会用eval… 28.不要信赖函数对象的toString()方法如题，因为在不同JS引擎中结果不同 29.避免使用非标准的栈检查工具arguments.caller虽然能告诉你函数的调用者，如果用它来实现栈检查工具，在函数调用本身的情况下，会陷入无限循环 Chapter4 对象和原型虽然JS支持继承，但不像传统语言，继承不是基于类，而是基于原型。 30.31.32.prototype/getPrototypeOf()/__proto__它们是对立但相关的访问器 C.prototype用于建立由new C()c创建的对象的原型 Object.getPrototypeOf(obj)是ES5中用来获取obj对象的原型对象的标准方法 obj.__proto__是获取obj对象的原型对象的非标准方法 因此，尽量用getPrototypeof(),尽量不去修改__proto__ 33.使构造函数与New操作符无关如果不使用new而是直接： 1var u = User('Jack', '18'); 如果内部用了严格模式，并给this.name赋值，会报错所以内部函数要考虑到这种情况，判断this是否是undefined，主动new一个 34. 在原型中储存方法如果在对象中储存方法，每个实例都会生成副本，而在原型中，只有一个 35. 闭包存储私有变量对象中的属性很容易通过this获取，如果有私有变量可以利用闭包存储 12345678function User(name, passwordHash) { this.toString = function() { return 'User ' + name; }; this.checkPassword = function(password) { return Hash(password) === passwordHash; }} 但是会牺牲一些，如34的问题，不能将该方法存在原型中。 36. 只将实例状态保存在实例对象中别保存在原型中，不然所有实例会共享，显而易见 37. this变量的隐式绑定问题经常遇到，this的作用域是由最近的封闭函数确定，解决该办法有三种方法 arr.map((v) =&gt; this.outerFunc(v), this) 有很多函数接受第二个参数绑定this var self = this; arr.map(... 在外部把this保存一下 arr.map((v) =&gt; this.outerFunc(v).bind(this)) 使用bind 38. 在子类中的构造函数调用父类的构造函数假设飞船SpaceShip是游戏中Actor的子类， 1234function SpaceShip(scene, x, y) { Actor.call(this, scene, x, y); this.point = 0;} 先调用Actor的构造函数，使Actor的实例属性添加到新对象中后续作为一个正确的子类，SpaceShip的原型必须继承Actor.prototype 12345// ✔️rightSpaceShip.prototype = Object.create(Actor.prototype);// ❌ wrongSpaceShip.prototype = new Actor(); 上述正确做法避免调用了Actor的构造函数。 39.不要重用父类的属性名如题 理解很简单 40.避免继承标准类如果继承标准类，其行为会被特殊的内部标记属性[[Class]]破坏如果child继承了array，child是object，不会有array的行为 41.将原型视为实现细节对象是接口，原型是实现 (？如何理解) 42.避免使用轻率的猴子补丁猴子补丁是指，假如Array缺少一个split方法，那么直接Array.prototype.split = ...创建一个方法。。 如果非要用，可以考虑封装在一个function中，调用给函数的代码才会修改原型 Chapter5 数组和字典43.使用Object的直接实例构造轻量级字典其实就是常用的做法，把一个Object直接当成字典来用但是文中指出了避免对其原型上增加方法，不然会导致错误(原型污染) 44.使用null原型防止原型污染用Object.create(null)创建空对象，不容易被污染（？）还是会在属性查找的时候，出现污染现象 45.使用hasOwnProperty避免原型污染这样不会拿到加在原型上的方法更严谨的：你不知道对象上的hasOwnProperty是否被覆盖了，可以这么办 12var hasOwn ={}.hasOwnProperty;hasOwn.call(obj, 'Alice'); 46.使用数组而不要使用字典来储存有序集合很简单明了，对象的key是无序的 47.绝不要在Object.prototype中增加可枚举的属性如果想增加方法给原型，会污染for…in方法，以下方式可以解决这个问题： 123456789101112Object.defineProperty(Object.prototype, 'allKeys', { value: function() { var result = []; for (var key in this) { result.push(key); } return result; }, writable: true, enumerable: false, configurable: true}) 48.避免在枚举之间修改对象 使用for…in的时候一定不要修改可枚举对象，会出现意外情况。 可改用for循环或者while 为了在一个可变的枚举对象中遍历，可以考虑再用一个额外的数组去保存信息 49.数组迭代优先使用for循环而不是for…in1234567var scores = [98, 74, 85, 77, 93, 100, 89];var total = 0;for(var score in scores) { total += score;}var mean = total / scores.length;mean; // ? 第一层❌：以上代码看似求平均值，得出88；第二层❌：for…in拿的是index，所以是0+1+2。。。total=21,mean=3;实际✔️：for…in拿的确实是index，但是是string，所以得到了total=’0123456’, 强制类型转化为了123456/7,得到17636.57…. 解决：用普通for循环即可 12// 更好的代码for(var i = 0, n = scores.length; i &lt; n; i++) {...} 提前计算出n，避免长度变化的影响 50.迭代方法优于循环 因为自己写for循环很容易写错初始条件，尽量用数组的forEach,map,filter,every,some等迭代方法。 同样的，对自己定义的抽象对象，也可以尽量实现迭代方法去遍历。 51.在类数组对象中复用数组方法举个例子： 12345function highlight() { [].forEach.call(arguments, function(widget){ widget.setBackground('yellow'); });} 像arguments、DOM中的Nodelist，都没有继承JS的Array原型，但是是类数组 类数组定义：这个例子不满足第二条：var arraylike = {0: 'a', 1: 'b', length: 2}因为，length不能自动变化 但是Array的几乎所有方法和length变化无关，因此arraylike可以用，除了concat 52.数组字面量优于数组构造函数使用这种字面量语法：var list = [1, 2, 3]优于这种构造函数语法：var list = new Array(1, 2, 3) 因为Array可能有人修改，可能有人包装过。。。(说得有道理，但是不常见) Chapter6 库和API设计53.保持一致的约定 变量命名和函数签名尽量一致 参数顺序尽量一致，比如先宽度，后高度 优秀的库都有完善的文档，如果文档保持一致，用户面对一些常见的任务就不用不停得看文档 54.将undefined看作“没有值” 避免使用undefined表示某一非特定值 不要用undefined表示特定标志 提供的默认参数用undefined检查，而不是arguments.length 在允许0、NaN、’’存在的情况，避免用真值测试(width || 300) 55.接受关键字参数的选项对象多参数虽然简单，但参数多的时候难以记忆:new Person(18, 'Bob')选项对象，不用记忆顺序：new Person({age: 18, name: 'Bob'}) 用选项对象使API可读性提高，减少记忆 一般所有的选项对象都是可选的 用extend函数(lodash.merge也可以吧？)抽象从选项对象中取值的逻辑 56.避免不必要的状态函数内部不保存状态，输入参数相同时，输出也相同。个人理解也就是纯函数。更加模块化、减少不同部分的影响、使代码更易于阅读。一个著名的有状态的API是Web的Canvas库，一开始学的时候确实费劲。。 57.使用结构类型设计灵活的接口举个例子，以下代码是我们将实现的功能： 1234567891011121314// Wiki.formats.MEDIAWIKI为格式化器var app = new Wiki(Wiki.formats.MEDIAWIKI);// Wiki将格式化函数存储在了wiki实例对象的内部function Wiki(format) { this.format = format;}// 每次渲染页面时，会调用Wiki的displayPage方法，内部实现如下：Wiki.prototype.displayPage = function(source) { var page = this.format(source); var title = page.getTitle(); var author = page.getAuthor(); var output = page.toHTML(); // ...} 方法一：使用类去实现格式化器创建一个Page基类，再实现一个继承Page的MWPage类(其他格式也都为Page的子类)，然后MEDIAWIKI则是一个返回MWPage实例的一个“工厂函数”，代码如下： 123456789101112131415function MWPage(source) { Page.call(this, source); // ...}// MWPage extends PageMWPage.prototype = Object.create(Page.prototype);MWPage.prototype.getTitle = /* ... */;MWPage.prototype.getAuthor = /* ... */;MWPage.prototype.toHTML = /* ... */;Wiki.formats.MEDIAWIKI = function(source) { return new MWPage(source);} 确实是OOP的做法，但问题是调用的3个方法都是自己实现的，并未从Page继承任何有用的代码。 方法二：结构类型12345678Wiki.formats.MEDIAWIKI = function(source) { // ... return { getTitle: function() { /* ... */ }, getAuthor: function() { /* ... */ }, toHTML: function() { /* ... */ }, };}; 只要displayPage方法结构正确，具有预期的getTitle、getAuthor、toHTML方法，那么这个格式化器就OK；比PAGE类更加灵活。 这种接口有时候称为结构类型或鸭子类型，优雅的轻量的编程模式。 58.区分数组对象和类数组对象有这么一个方法，支持入参为 一个数组或一个对象，也就是实现了方法的重载。那么就必须在方法内部去判断这个入参是数组还是对象，这时候就要考虑类数组的概念了（51条），类数组是一个对象但是可以被视为数组，所以如何区分？因此引出了如下规则： API绝不应该重载与其他类型有重叠的类型不完美的方案：if (x instanceof Array)。跨frame通信时，会有多个Array的原型副本，是不同的。更好的方案：if (Array.isArray(x))。 59.避免过度的强制转换如题所示，本人几乎不去用强制类型转换。 避免强制类转换和重载的混用 考虑防御性地监视非预期的输入(对入参进行类型判断)如果用TS多了，这种问题基本上不会有。。 60.支持方法链无状态的API的好的例子：String的replace方法、Array的map、filter方法。有状态的API也值得支持，在更新对象时返回this。 123element.setBackgroundColor(&quot;yellow&quot;) .setColor(&quot;red&quot;) .setFontWeight(&quot;bold&quot;); Chapter7 并发61.不要阻塞I/O事件队列 主要是用异步函数和回调去避免阻塞。 JavaScript并发地接收事件，但会使用一个事件队列按序地处理程序 最重要的原则：绝不要在应用程序事件队列中使用阻塞I/O的API 62.在异步序列中使用嵌套或命名的回调函数 使用嵌套或者命名的回调函数按顺序地执行多个异步操作。（合理的处理回调地狱。。） 尝试在过多的嵌套的回调函数和尴尬的命名的非嵌套回调函数之间取得平衡。 避免将可被并行执行的操作顺序化 63.当心丢弃错误 写共享的错误处理函数来避免复制和粘贴错误处理代码 确保异步操作的所有错误情况都处理了，避免丢弃错误 64.对异步循环使用递归想要实现的效果：一个文件下载完，继续下另一个，但给的是一个urls。 12345678910111213function downloadOneAsync(urls, onsuccess, onfailure) { var n = urls.length; function tryNextURL(i) { if (i &gt;= n) { onfailure(&quot;all downloads failed&quot;); return; } downloadAsync(urls[i], onsuccess, function() { tryNextURL(i + 1); }); } tryNextURL(0);} 循环不能异步 使用递归在时间循环的单独轮次中执行迭代 在回调函数中执行递归，不会导致栈溢出 65.不要在计算时阻塞事件队列JS代码在进行长时间计算时，会使web页面无响应。 方案1：Worker API有一个技术可以解决Web平台的Worker API，以下场景，比如一个要搜索大量可移动距离的人工智能游戏，如果在单线程环境下，会卡顿无响应。 123456789101112131415// main.js// 产生一个新的线程独立的事件队列的并发执行线程。var ai = new Worker(&quot;ai.js&quot;);// 主线程需要ai的数据时，通过postMessage的方式交互var userMove = /* ... */;// 需要重新计算用户移动ai.postMessage(JSON.stringify({ userMove: userMove}));// 处理worker线程的响应ai.onMessage = function(event) { excuteMove(JSON.parse(event.data).computerMove);} AI的代码 1234567891011self.onMessage = function(event) { var userMove = JSON.parse(event.data).userMove; var computerMove = computeNextMove(userMove); self.postMessage(JSON.stringify({ computerMove: computerMove })); function computeNextMove(userMove) { // ... }} 方案2：分解算法。组成可管理的工作块搜索社交网络图的算法，改造前的算法while循环代价过高，会阻塞。如果用方案1，还要复制整个网络图的状态或在worker中存储网络图的状态，传递消息来更新和查询网络。 1234567891011121314151617181920212223242526272829303132333435// 改造前Member.prototype.inNetwork = function(other) { var visited = {}; var worklist = [this]; while (worklist.length &gt; 0) { var member = worklist.pop(); // ... if (member === other) { // found return true } // ... } return false}// 改造后Member.prototype.inNetwork = function(other, callback) { var visited ={}; var worklist = [this]; function next() { if (worklist.length === 0) { callback(false); return; } var member = worklist.pop(); // ... if (member === other) { // found callback(true); return; } // ... setTimeout(next, 0); // schedule the next iteration } setTimeout(next, 0); // schedule the first iteration} 利用回调函数拿到异步查询的结果，查询过程中不会阻塞。但如果在一个应用程序事件队列中只执行算法的一个迭代，有点杀鸡用牛刀，可以稍微调整下，在next函数中加一个循环，每进行10次循环再setTimeout(next, 0) 66.使用计数器来执行并行操作并行发生的事件，回调函数的执行顺序是未知的，注意返回结果的顺序。解决：用数组的index去保存结果(JS不会报index出边界的错误。。)，用计数器保证所有成功的时候回调。 12345678910111213141516171819202122232425function downloadAllAsync(urls, onsuccess, onerror) { var pending = urls.length; var results = []; if (pending === 0) { setTimeout(onsuccess.bind(null, result), 0); return; } urls.forEach(function(url, i) { downloadAsync(url, function(text) { if (result) { result[i] = text; pending--; if (pending === 0) { onsuccess(result); } } }, function(error) { if (result) { result = null; onerror(error); } }) });} 67.绝不要同步地调用异步的回调函数 即使可以立即得到数据，也绝不要同步地调用异步回调函数。 同步地调用异步的回调函数扰乱了预期的操作序列，并可能导致意想不到的交错代码。 同步地调用异步回调函数可能导致栈溢出或错误地处理异常 使用异步的API，比如setTimeout去调度异步回调函数 68.使用promise模式清洁异步逻辑promise经常用，就不细说了 promise代表最终值，即并行操作完成时最终产生的结果 使用promise组合不同的并行操作 使用promise模式的API避免数据竞争 在要求有意的竞争条件时使用select(早期的API吧，后期有race)","link":"/myBlog/2021/05/15/Effective-javascript/"},{"title":"深入React技术栈-Chapter3-React源码","text":"1. 初探React源码React源码的组织结构 而renderers目录结构是这样的 client是客户端操作dom的一些方法；server是服务端渲染的实现和方法；event包含有一套自定义的事件插件系统；作为React核心的reconciler，称为协调器，管理组件的实现、生命周期、setState、DOM diff算法;管理Virtual DOM 2. Virtual DOM 模型ReactNodeVirtual DOM的节点叫作ReactNode 12type ReactNode = ReactElement | ReactFragment | ReactText;type ReactElement = ReactComponentElement | ReactDOMElement; // 差一些 ReactDOMComponent 属性的更新，包括更新样式、更新属性、处理事件等; 子节点的更新，包括更新内容、更新子节点，此部分涉及diff算法。 // 差很多","link":"/myBlog/2022/02/21/%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88-Chapter3-React%E6%BA%90%E7%A0%81/"},{"title":"深入React技术栈-Chapter1-2","text":"1.React基础React生命周期 无状态组件 无状态组件挂载时只是函数的调用，没有创建实例。 因此findDOMNode和refs都不能用，同时建议，这两个方法尽量别用，会打破封装性。 在能用无状态组件的情况下，尽量用无状态组件 React之外的DOM操作尽量不用DOM操作为了保证封装性，但有时有一些操作没办法避免 H5的video的play和input的forcus 点击其他区域合上该组件 计算DOM的尺寸自己的理解：用hooks解决以上2，3问题，保证了一定的封装性？ 2.事件合成事件的实现机制事件委派和自动绑定 事件委派：有一个统一的事件监听层，并不会把事件处理函数直接绑定到真实的节点上。 自动绑定：React组件中，每个方法的上下文都会指向该组件的实例，即this自动指向当前组件。 三种手动绑定方法如果用ES6 classes或者纯函数，就没自动绑定了，需要手动绑定： 1.bind方法绑定 1return &lt;button onClick={this.handleClick.bind(this, 'tes')}&gt;Test&lt;/button&gt; 2.构造器内声明class中的方法不用箭头函数，就必须绑定 1234567// 在constructor中：this.handleClick = this.handleClick.bind(this);// 在 class中handleClick(e) { ...} 3.箭头函数如果使用箭头函数，可以直接这样： 12345678class App extends Component { const handleClick = (e) =&gt; { console.log(e); } render() { return &lt;button onClick={this.handleClick}&gt;Test&lt;/button&gt; }} React合成事件的限制React 的合成事件系统只是原生 DOM 事件系统的一个子集。它仅仅实现了 DOM Level 3 的事件接口，并且统一了浏览器间的兼容问题。有些事件 React 并没有实现，或者受某些 限制没办法去实现，比如 window 的 resize 事件 React合成事件和JS原生事件的对比1. 事件传播与阻止事件传播原生DOM事件三阶段：1.事件捕获 2.事件处理 3.事件冒泡 而React没有实现事件捕获，因为其在开发中意义不大 (?) 2.事件类型React 合成事件的事件类型是 JavaScript 原生事件类型的一个子集 3.事件绑定方式不多说了 4.事件对象原生 DOM 事件对象在 W3C 标准和 IE 标准下存在着差异。在低版本的 IE 浏览器中，只能使用 window.event 来获取事件对象。而在 React 合成事件系统中，不存在这种兼容性问题，在事件处理函数中可以得到一个合成事件对象。 3.表单受控组件React 受控组件更新 state 的流程: (1) 可以通过在初始 state 中设置表单的默认值。 (2) 每当表单的值发生变化时，调用 onChange 事件处理器。 (3) 事件处理器通过合成事件对象 e 拿到改变后的状态，并更新应用的 state。 (4) setState 触发视图的重新渲染，完成表单组件值的更新。 4.CSSCSS模块化CSS模块化的问题 全局污染:CSS 使用全局选择器机制来设置样式，优点是方便重写样式。缺点是所有的 样式都是全局生效，样式可能被错误覆盖，因此产生了非常丑陋的 !important，甚至 inline !important 和复杂的选择器权重计数表1 ，提高犯错概率和使用成本。Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它把样式彻底局部化，造成 外部无法重写样式，损失了灵活性。 命名混乱:由于全局污染的问题，多人协同开发时为了避免样式冲突，选择器越来越复 杂，容易形成不同的命名风格，很难统一。样式变多后，命名将更加混乱。 依赖管理不彻底:组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样 式。现在的做法是除了要引入 JavaScript，还要再引入它的 CSS，而且 Saas/Less 很难实现 对每个组件都编译出单独的 CSS，引入所有模块的 CSS 又造成浪费。JavaScript 的模块化 已经非常成熟，如果能让 JavaScript 来管理 CSS 依赖是很好的解决办法，而 webpack 的 css-loader 提供了这种能力。 无法共享变量:复杂组件要使用 JavaScript 和 CSS 来共同处理样式，就会造成有些变量 在 JavaScript 和 CSS 中冗余，而预编译语言不能提供跨 JavaScript 和 CSS 共享变量的这种 能力。 代码压缩不彻底:由于移动端网络的不确定性，现代工程项目对 CSS 压缩的要求已经到 了变态的程度。很多压缩工具为了节省一个字节,会把 16px 转成 1pc，但是这对非常长的 类名却无能为力 CSS与JS变量共享12345/* config.scss */ $primary-color: #f40;:export { primaryColor: $primary-color;} 1234/* app.js */import style from 'config.scss';// 会输出 #F40 console.log(style.primaryColor); css Modules使用技巧 不适用选择器，只用class名来定义样式 不层叠多个class，只用一个class把所有样式定义好 通过composes组合来实现复用 不嵌套 如果在style文件中使用id选择器、伪类和标签选择器，不会被转换或者加前缀 react-css-modules库可以避免重复输入styles.** 1234567891011121314151617181920import React, { Component } from 'react';import classNames from 'classnames';import CSSModules from 'react-css-modules';import styles from './dialog.css';class Dialog extends Component { render() { const cx = classNames({ confirm: !this.state.disabled, disabledConfirm: this.state.disabled, }); return ( &lt;div styleName=&quot;root&quot;&gt; &lt;a styleName={cx}&gt;Confirm&lt;/a&gt; // ... &lt;/div&gt; ); }}export default CSSModules(Dialog, styles); 使用 CSS Modules，容易使用 :global 去解决特殊情况，使用 react-css-modules 可写成 ，这种形式轻松对应全局和局部; 5.React组件组件通信 父向子通信：属性 子向父通信：回调 跨级通信：在父组件中定义ChildContext,子组件可以直接用this.context拿到对应的值；context可以存在很多级 无嵌套关系通信：使用Events模块的事件订阅和发布来实现 组件间抽象mixinJS中的mixinmixin是为了弥补一些老的OOP语言不能实现多重继承的缺点，而采用的另外一个方法 1// TODO 有空自己实现一下 React中的mixin 适用于createClass的情况。。比较老了，不再细讲 使用ES6 Classes和decorator，用法：123456789101112import React, { Component } from 'React';import { mixin } from 'core-decorators';const PureRender = { shouldComponentUpdate() {}};const Theme = { setTheme() {}};@mixin(PureRender, Theme)class MyComponent extends Component { render() {} } 但是mixin也有命名冲突、破坏原组件的封装性等问题 高阶组件解释：React组件被包裹，高阶组件会返回一个增强的React组件。实现高阶组件有两种方式：属性代理和反向继承 属性代理1234567import React, { Component } from 'React';const MyContainer = (WrappedComponent) =&gt; class extends Component { render() { return &lt;WrappedComponent {...this.props} /&gt;; } } 当然，也可以使用装饰器语法。调用顺序didmount→HOC didmount→(HOCs didmount)→(HOCs will unmount)→HOC will unmount→unmount 反向继承123456const MyContainer = (WrappedComponent) =&gt; class extends WrappedComponent { render() { return super.render(); } } 特点：渲染劫持，控制state(大部分高阶组件都应该限制读取或增加state，防止混乱) 组合式组件组合式的方式意图打破这种关联，寻求单元化，通过颗粒度更细的 基础组件与抽象组件共有交互与业务逻辑的高阶组件，使组件更灵活，更易扩展，也使我们能够 完成对于基础组件的自由支配。 组件性能优化纯函数的定义 给定相同的输入，总返回相同的输出 过程没有副作用 没有额外的状态依赖理解：1.好理解。2.入参有个对象，函数内是该对象的引用，对其进行改变，就是所谓的产生了副作用。可以用immutable的概念去解决，用lodash的cloneDeep。3.在方法内不使用共享变量，内部所有变量只在方法的生命周期内存活，拒绝闭包？ PureRender重新实现shouldComponentUpdate方法，对props和state做浅比较，值对比引用(深比较实在太昂贵了)以下类型，无论如何都会触发pureRender的重渲染： props直接设置为对象或数组1&lt;Account style={{color: 'black'}} /&gt; 因为每次都是重新生成了一个新对象，数组同理；解决：先定义一个变量即可。 设置props方法并通过事件绑定在元素上1&lt;input onChange={this.handleChange.bind(this)} /&gt; 每次会重新生成新函数对象(箭头函数也同理？)。解决：bind放在constructor内 设置子组件12345678&lt;Item&gt; &lt;span&gt;Arcthur&lt;/span&gt;&lt;Item/&gt;// 翻译后 每次都生成了新对象&lt;Itemchildren={React.createElement('span', {}, 'Arcthur')}/&gt; 解决：使用Item组件的父组件也要pureRender Immutable引用赋值的问题：容易改变，复杂系统有隐患。深拷贝：浪费内存 Immutable DataImmutable Data被创建后，不能更改。如果对原数据修改，会生成一个新的Immutable对象。Immutable.js库就是这样的理念 Immutable的优点复杂度降低；节省了内存，因为节点是共享的；重做/撤销、复制/粘贴都可以实现，老数据都存着呢；并发安全，对于JS来说好像无关紧要，单线程。。；拥抱函数式编程，其本就是函数式编程的概念。 缺点api还是和原生map array有区别 Immutable 与 PureRender用immutable的is去改造shouldComponentUpdate即可 keyArray&lt;Element&gt;渲染时，每一个item都要唯一的key，切不建议使用index，建议使用id或shortid 性能检测工具react-addons-perf使用Perf.start()和Perf.stop()分析 6.动画后续添加 7.自动化测试后续添加","link":"/myBlog/2021/11/29/%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88-Chapter1-2/"},{"title":"Nand2Tetris Part1","text":"简介：Coursera网课笔记，从一个门电路开始，搭建一台电脑。课程地址：https://www.coursera.org/learn/build-a-computer作业仓库：https://github.com/ig505gi/Nand2Tetris-homework Week1 布尔运算和逻辑门1.1 运算法则 1.2 NAND任何一个布尔函数都可以用只含有AND和NOT操作符的表达式来表示；而NAND是NOT和AND的结合，因此：任何一个布尔函数都可以用只含有NAND操作符的表达式来表示 1.3 XORps: HDL: Hardware Design Language 1.4 Multiplexor和DemultiplexorHDL中的subBuses：Multiplexor非常有用，可以从多条数据中选出其中的一条Demultiplexor可以从一条数据中按照规律解析成多条数据 Week2 加法和算术逻辑单元ALU2.1 半加器和加法器半加器真值表： 输入输出 a b sum carry 值 0 0 0 0 值 0 1 1 0 值 1 0 1 0 值 1 1 0 1 全加器真值表和接口 2.2 负数和补位从左起第一位为0的为正数，为1的为负数，x+(-x)=0，如果不考虑进了一位，也就是2^n 2.3 ALUCPU里的核心计算单元，该项目里设计的比较简单 Week3 内存3.1 Sequential Logic &amp; DFF序列逻辑可以在一个位置存放所有的信息(这句怎么理解？)DFF: Data Filp Flop特点：1.自己需要保存一个状态，2.该状态取决于上一个时间unit的输入 3.2 Register寄存器1-Bit Register内部用一个DFF和一个Mux可以实现。16个1-Bit Register组合在一起成为一个16位寄存器 3.3 RAMRegister堆在一起组成RAM，图中的小三角代表是一个Sequential chip读：设置address为i就好写：设置address为i，in为v，load为1 RAM16K我们的电脑内存是16K的，如何用HDL来写？首先实现RAM8.png，tips:8个16bit-Register组成RAM8,8个RAM8组成RAM64。。。。。 3.4 Counter计数器，内部用DFF实现，每过一个时间单位，能自动加一 Week4 机器语言4.1 Machine Language Overview一门机器语言应该有哪些成分？操作符，逻辑运算，流程控制，寻址功能，IO。 如果硬件复杂，可以实现乘除法，机器语言可以包含乘除法，如果硬件简单，可以只有加法； 同样，如果硬件复杂，可以设计负数，浮点型数据类型。如果硬件简单，只有正数 ps: 这里强调tradeoff，一些功能到底设计在硬件层面还是软件层面，由设计者决定。 4.2 Hack ComputerHack电脑认识的机器语言叫Hack语言，由两位教授设计的。 硬件 软件 控制和寄存器 ROM中加载了Hack语言 reset按钮一按，程序开始执行 三个寄存器用来实现Hack语言：A M D，目前先不用管CPU里如何设计，第五章会讲 4.3 Hack Language汇编语言时人能看懂的语言，转化成二进制才是机器认识的机器语言Hack语言含有A命令和C命令 A命令 C命令 4.3 IO屏幕RAM中有一块专门管屏幕的内存screen memory map，hack电脑用512X256像素的黑白屏 键盘RAM中有一个16bit-Register管键盘 4.4 Hack program如果程序不终止，有人在ROM后面写入了恶意命令，就会被执行。如何终止程序：写一个无限循环即可 123// line 6@60;JMP 内置标识符为了方便编程，内置了一些标识符 分支使语言更具有可读性，一般为大写字母 变量也是更具有可读性，不用在其他地方声明，一般为小写字母，而分支需要在其他地方声明 迭代用以上功能实现迭代的功能 指针A寄存器实际上就是一个指针的功能 Week5 电脑架构5.1 整体架构图 5.2 CPU内部具体实现非常优雅，值得细品 Week6 汇编器Assembler用汇编器将汇编语言变成机器语言，可以用高等语言去写，前提是有其他电脑被造出来了。如果没有电脑，只能手工去费时费力的去转化。 汇编器的架构：","link":"/myBlog/2022/06/18/Nand2Tetris-Part1/"},{"title":"Java面向对象-慕课学习笔记","text":"简介：慕课网课笔记，主要讲述Java的面向对象思想。用对象思考，用类来写作课程地址：https://www.icourse163.org/course/ZJU-1001542001?tid=1003687002作业仓库：https://github.com/ig505gi/JAVA-Course Part11.类的定义 1.1 对象、函数对象 = 属性 + 服务数据：属性，状态操作：函数操作是包含着数据的，把数据和对数据的操作放在一起，数据不对外面公开–&gt;封装 1.2 this在成员函数内部可以用this调用其他成员函数 1.3 成员变量&amp;本地变量本地变量：生存期和作用域都在函数内部，定义在函数内部成员变量：生存期是对象的生成期，作用域是类中的成员函数，定义在类中 1.4 构造函数构造函数与类名相同，没有返回类型，重载：可以有多个构造函数，根据参数不同调用不同的构造函数创建对象的时候，先调用构造函数，再初始化成员变量，再进入构造函数内部。 1.5 toString()可以用于任何一个类中，使类的输出变成想要的结果 2 对象交互2.1 访问属性private私有成员是类的私有，不是对象的私有，可以在类中访问不同对象的私有变量。friendly如果前面不加访问属性，就是friendly，在同一个包里可以使用 2.2 类变量static 静态变量，是类的变量，不是对象的变量，可以用”类.“去访问同样，函数前加 static，函数是类函数。static函数只能调用static函数，只能访问static变量 2.3 public&amp;编译单元public 类的定义加上public，该类一定在以该类命名的java文件中，如：public class test{} 一定在test.java中一个 **.java是一个编译单元，里面只能有一个public类，并且和文件名相同 3 包3.1在一个包pac下面的的每个java文件一定有一行package pac包中类的调用方式： 4 对象容器4.1 定义ArrayList&lt;String&gt; notes = new ArrayList&lt;String&gt;();定义了一个存放String的ArrayList，ArrayList是一种范型类，就是一种容器容器的输出带着方括号 4.2 对象数组对象数组的每一个元素都是对象的管理者，而非对象本身不像int数组，for-each循环的时候，不能对每个元素赋值，对象数组和对象容器都可以在for-each循环中，对对象的成员变量赋值。 4.3 set定义HashSet&lt;String&gt; notes = new HashSet&lt;String&gt;();HashSet没有重复元素，乱序 4.4 Hash(类似python中字典)HashMap&lt;Integer, String&gt; hm = new Hashmap&lt;Integer, String&gt;();需要用Integer，int的包裹类型，都是类的名字hm.put(5, &quot;five&quot;) 用于往HashMap的对象中放元素重复key进行put，value会覆盖 5.继承与多态5.1 定义class &lt;子类名字&gt; extends &lt;父类名字&gt; {} 5.2 父子类的关系 父类成员访问属性 在父类中的含义 在子类中的含义 public 对所有人开放 对所有人开放 protected 只有包内其它类、自己和子类可以访问 只有包内其它类、自己和子类可以访问 缺省 只有包内其它类可以访问 如果子类与父类在同一个包内：只有包内其它类可以访问，否则：相当于private，不能访问 private 只有自己可以访问 不能访问 在构造一个子类的对象时，父类的构造方法也是会被调用的，而且父类的构造方法在子类的构造方法之前被调用如果我们试图重新定义一个在父类中已经存在的成员变量，那么我们是在定义一个与父类的成员变量完全无关的变量，在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们同名但是互不影响 5.3 supersuper()在构造函数第一行执行，进入父类的构造函数，可以重载，调用不同的构造函数在子类中使用父类的函数，super.parentsFunction() 5.4 多态变量和向上造型JAVA中的变量都是多态变量，比如一个放水果的变量，可以放苹果，也可以重新放橘子，但是不能放打印机当把一个子类对象赋给父类变量时，发生了*向上造型 例子：CD是Item的子类 12345Item item = new Item();CD cd = new CD();item = cd；CD cc = item; // 不对，编译不通过CD cc = (CD)item; // 将Item类变量item当做CD类型去给cc变量赋值 用括号加类型放在变量前面的操作就叫做造型造型和（int）转换类型不同的！！一个是转换类型，一个是造型造型时，有可能出现ClassCastException的错误 5.5 绑定当调用一个方法时，究竟应该调用哪个方法，这件事情叫做绑定。绑定有两种：一种是早绑定，又称静态绑定，这种绑定在编译的时候就确定了，根据变量的声明类型决定；另一种是晚绑定，即动态绑定。动态绑定在根据变量的动态类型决定。Java缺省使用动态绑定。 5.6 overrideoverride 覆盖通过父类的对象调用存在覆盖关系的函数时，会调用变量但是所管理的对象的类的函数利用IDE进行override时 在函数上会有@Override字段，如果该覆盖函数与父类的访问属性、返回类型、名称、参数表有不同，就会报错 6 抽象类6.1 定义public class abstract shape{ public abstract void draw(Graphcs g); }我们没有想过要真正实现一个shape类的对象, 但是要保存一些图形共有的属性。抽象类不能实例化 子类中的函数必须全都覆盖抽象父类中的抽象函数，这叫做实现如果没有全部实现，子类也是抽象类 7. 接口7.1 定义声明 public interface 接口名接口是纯抽象类所有的成员函数都是抽象函数，所有的成员变量声明都是 public static final接口规定了长什么样，但不管里面是什么 7.2 类实现如何声明public class Fox extands Animal implements Cell {}定义了一个 Fox类，继承自 Animal类， 实现了 Cell接口 7.3 接口变量(自己命名)Cell c = new Fox();一个Cell接口的变量可以赋于任何一个实现了Cell接口的类 7.4 使用规则（1）接口是一种特殊的类，在使用上一样（2）类可以实现很多接口（3）接口可以继承接口，但不能继承类（4）接口不能实现接口 8. 内部类在一个A类的内部定义了一个B类，我就称这个B类为内部类内部类B可以访问A类的成员函数、成员变量，如果定义在A的外部，如果B想访问A类的成员，需要将A类实例化（很麻烦） 内部类也有可能在函数内(如下文中的匿名类)在函数内不能访问本地变量，只能访问有final修饰的本地变量 9. 匿名类这里定义的就是一个匿名类 在new对象的时候给出的类的定义形成了匿名类，匿名类可以实现某接口，也可以继承自某个父类， Swing框架的消息机制广泛运用匿名类 10.finalinal关键字是我们经常使用的关键字之一，它的用法有很多，但是并不是每一种用法都值得我们去广泛使用。它的主要用法有以下四种： 1.用来修饰数据，包括成员变量和局部变量，该变量只能被赋值一次且它的值无法被改变。对于成员变量来讲，我们必须在声明时或者构造方法中对它赋值； 2.用来修饰方法参数，表示在变量的生存期中它的值不能被改变； 3.修饰方法，表示该方法无法被重写； 4.修饰类，表示该类无法被继承。 上面的四种方法中，第三种和第四种方法需要谨慎使用，因为在大多数情况下，如果是仅仅为了一点设计上的考虑，我们并不需要使用final来修饰方法和类。 Part21.一些设计原则1.1. 消除代码复制1.2. 封装用封装来降低耦合 1.3. 可扩展性用 框架+数据 提高扩展性方法：i）命令的解析是否可以脱离if-else ii）定义一个Handler类来处理命令 iii）用Hash表来保存Handler和命令的关系 1.4. 接口的引入设计程序时，先定义接口，再实现类任何需要在函数间传入传出的一定是接口而不是具体的类 2.设计思想2.1. 控制反转[图丢失]Jbutton类想要实现按下去，调用step()的操作，但是我们不能在Jbutton类中再定义，是原本的框架。但是Jbutton类实现了ActionListener接口，并且有addActionListener函数。ActionListener接口中只有一个actionPerfomed函数， btnStep实例执行addActionListener函数后，就将actionPerfomed函数注册给了btnStep当btnStep被按下去的时候，就会执行外部override的actionPerfomed函数。 2.2. MVCView-Model-ControlView 和 Control不直接有关系，通过Model(模型、数据)来连接 3.加载类https://www.cnblogs.com/doit8791/p/5820037.html ps： 在18年学习的，但是未发布在个人博客，2022年整理并同步到个人博客","link":"/myBlog/2018/12/25/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E6%85%95%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"零基础Java-慕课学习笔记","text":"简介：慕课网课笔记，从零学习Java语法课程地址：https://www.icourse163.org/course/ZJU-1001541001?tid=1003042007作业仓库：https://github.com/ig505gi/JAVA-Course 1.IDE使用技巧Alt+/ 补全 control+/ 注释某一行 （mac下 是 command） shift+↑ 选中光标移动行 eclipse右上角可以切换java模式和debug模式 debug时，step over是跳过函数，step into是进入函数 2.输出和输入2.1 string与数字类型转化demosystem.out.println(2+3+“=2+3=”+2+3)； 控制台输出：5=2+3=23 2.2 格式化输出println输出回车 print不输出回车 输出两位有效数字System.out.printf(&quot;%.2f&quot;, 7.128741) 2.2 输入Scanner in = new Scanner(System.in); in.next() –&gt;读入一个单词，结束的标志位空格(包括tab和换行) in.nextLine() –&gt;读入一整行 in.nextInt() –&gt; 读入一个整型 3.定义常量final 4.结合关系及优先级一般从左向右，而赋值运算从右向左 判断优先级很低，最后做 5.强制类型转换System.out.println((int)(170.239)); 6.最大的数20！不能算，最大到2e31-1 7.循环7.1 forfor循环的（；；）每个分号之间都可以空着，也可以用逗号链接多个句子，是唯一一处可以用逗号链接构成长句子的地方 7.2 break/continue要离开多重循环的时候，可以在需要的for前加上一个限定词 如OUT 然后在多重循环里面 break OUT；即可结束多重循环 continue 同理也可以这样使用 7.3 for-each循环12int[] nums = new int[2]for(int item : nums){ item = 1;} 理解：1.for-each循环的格式与C#不同，要记住。 2。取出item赋值不会改变原数组的值，只有nums[i]调用赋值才能改变 8. 数组8.1 数组索引、长度编译器不检查数组的索引是否有效，只有运行的时候才会出错超出索引范围 获取num[10]数组的长度：num.length 8.2 数组变量、数组复制int[] b = a 该行代码使得b指向了a所指向的数组，改变a[i]的同时，b[i]也会变，反之也会变 b称之为数组变量，如果比较数组变量，比较的是两个数组变量是否管理一个数组 9.字符串9.1 charchar类型是单个字符 12char ch = 'a';char c = '字'; java用的Unicode编码，汉字也是一个字符 ch++ –&gt; b char类型加1得到ASCII码表后面的一个字符 char ch='\\u0041' == char ch=65 == char ch='A' 代表16进制的ASCII码值，即65 –&gt;A 字符可以做加减法，得到的值是int 字符可以比较大小，比较的是ASCII值 9.2 逃逸字符\\b 回退一格，在Eclipse里面不会执行，需要到console才行。并且只是光标回退一格，接下来的输出从这里开始，不会删除只会被覆盖 \\t 到下一个表格位 12System.out.println(&quot;123\\tabc&quot;)System.out.println(&quot;12\\tabc&quot;) 输出： 12123 abc12 abc \\r 回车 \\n 换行，来源老式打印机，现在使用可能差不多？ 10.包裹类型int –&gt; Integer, char –&gt; Character 包裹类型的意义：可以用点运算符，eg： Integer.Max_VALUE 得到int型的最大范围 Character.toLowerCase('A') –&gt; a, 可以使用许多方法 11.String11.1 定义注意：String 的S是大写，和其他类型不一样，而是和包裹类型一样 String s = new String(&quot;Hello world&quot;) 11.2 比较String的定义和数组一样需要用new，也就说明了和数组一样定义的是管理者，还不是所有者 因此，s == &quot;Hello world&quot;返回的是false 需要用 s.equals(&quot;Hello world&quot;) 返回的是true 11.3 索引用s.length() 可以获取长度 遍历的时候跟数组一样 s[index] 但是不能用for-each循环 11.4 常用操作s.compareTo(&quot;Hello worlf&quot;) –&gt; 返回 -2 一个字符一个字符比较，返回比它小多少 s.indexOf('e') –&gt; 返回 1 s.indexOf(&quot;ell&quot;) –&gt; 返回 1 开始的index s.indexOf('a') –&gt; 返回 -1 s.trim() 去掉两边的空格 s.startsWith(t) 是否以t开始 s.replace(c1,c2) 用c2代替c1 s.toLowerCase() 变成小写 11.5 StringBuffer123String re = &quot;&quot;re += &quot;first&quot;re += &quot;second&quot; 这样的代码对系统开销很大,因为String是一种不可以修改的对象，每一次“+=”操作都会产生一个String对象优化 1234StringBuffer sb = new StringBuffer()；sb.append(&quot;first&quot;);sb.append(&quot;second&quot;);String re = sb.toString(); ps： 主要记录基本语法和之前学过的语言不太一样的知识点，或者容易忘记的知识点 网课老师为浙大翁恺教授，绝对男神！！不仅会教Java，还会教一些很Geek的tips，很实用！ 在18年学习的，但是未发布在个人博客，2022年整理并同步到个人博客","link":"/myBlog/2018/12/24/%E9%9B%B6%E5%9F%BA%E7%A1%80Java-%E6%85%95%E8%AF%BE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"Nand2Tetris-Part2","text":"简介：Coursera网课笔记，已经在Part1用硬件造出了电脑，准备实现OS、VM、编译器、高级编程语言。课程地址：https://www.coursera.org/learn/nand2tetris2作业仓库：https://github.com/ig505gi/Nand2Tetris-homework Week1 Overview和VM part10. Overview软件层面，我们如何从高级编程语言一步步转化为机器语言本周的内容主要是VM的实现part1 0.1 VM OverviewVM中应该有四种命令：算术/逻辑、内存访问、分支、函数本周为part1，作为project7，只会涉及算术/逻辑、内存访问；而分支和函数则在week2作为part2，在project8中实现。 1. Stack &amp; Memory Segment concept1.1 Stack在VM中，重要的对象stack，stack除了我们所熟知的push和pop方法，还有一些可以简化操作的方法 add: 将栈顶的两个值相加，并放回栈顶 neg: 对栈顶的值求负，并放回栈顶 eq: 比较栈顶的两个值，将是否相等的布尔值放回栈顶 or: 对栈顶的两个值进行逻辑or的操作，并放回栈顶 以此类推。。（图中eq应该是x==y） 1.2 Memory Segment在内存中存放的值，会分不同的片段，push和pop主要是在stack和segment之间来回通信的操作。一共有8种Segment：local, argument, static, constant, this, that, pointer, temp 2. VM Implement2.1 指针：如何从VM code到Machine codeMemory Segment和stack的push和pop方法，都属于抽象的概念。如何转化为我们的机器语言和RAM交互逻辑？要借助指针的概念： 2.2 stack Implement抽象的stack machine：从push到指针再到Hack语言 注意：stack的指针SP，一直指向栈顶。 2.3 local/argument/this/that Segment Implement这四个segment的作用和分工： 方法的本地变量或入参放在local和argument中 方法可访问到的对象和数组放在this或that中； 注意，与stack不同:local/argument/this/that的指针, 一直指向base。 图中的pop local 2用hack assembly实现： 12345678910111213// 必须借助其他内存空间才能完成@2 // Addr = LCL + 2D=A@LCLD=M+D@R13M=D@SP // SP--, D=*SPAM=M-1D=M@R13 // *Addr = DA=MM=D push local 5实现： 12345678910@5 // addr = LCL + 5D=A@LCLA=M+DD=M@SP // *SP = *addrA=MM=D@SP // SP++M=M+1 argument/this/that和local的实现是一致的 2.4 constant Segment Implementconstant没有pop操作，也在内存里没有对应的地址push constant i 转化为 *SP = i, SP++ 2.5 static Segment Implement static因为要保证去全局唯一，比较复杂，加上文件前缀；16~256 文件名+.+数字 确定一个唯一的Label 2.6 temp Segment Implement 当编译高级语言的时候，可能会需要一些变量暂时存储，我们的VM只提供8个暂时变量 5~12，实现上几乎和local等是一样的。 不同点是LCL是指针，@LCL是指针操作，要拿出存在LCL位置的值在加上index；而temp是@5（5是temp的base），然后5+index。 2.7 pointer Segment Implement 注意：跟其他的不同点，该操作的是this或that指针，而其他操作的都是指针指向地址的值 pointer为什么需要：之后写编译器的时候才会解释pointer的值只有0或1，当0的时候就是访问this，当1的时候，访问that 2.8 Hack平台的约定/标准这些segment在哪里，在Hack平台都是约定好的用约定好的标识符 3 VM translator可以用python或者java等语言去写，主要架构如下：其中parser的主要API：codeWriter的主要API： 4. project7code now! Week2 VM part20. overview涉及算术/逻辑、内存访问已经在week1学习。接下来要学习的有以下知识： Branching Functions Function call-and-return Dynamic memory management Stack processing Pointers 然后就完成了VM的实现。 1. branchingbranching和assembly中的branch几乎一样。 2. functions(重点)2.1 overview/abstractionfunction：在其他地方也有叫method，一个意思。一个函数从高阶语言编译成vm伪代码，再到vm代码 2.2 caller and callee左侧的main函数是caller，右侧mult函数是callee，在每个函数内，他们视角中的stack和内存segment是不同的。抽象的说一个call命令，应该做什么；一个return命令，应该做什么在一个函数内，也是通过stack和memory segement之间的push/pop操作来进行计算的，那么，当caller调用了callee的时候，caller的状态必须保存下来，运行完callee后，恢复caller的状态，接着运行caller。 2.3 implementcaller的视角callee的视角vm代码 2.3.1 handling call 2.3.2 handling function 2.3.3 handling return 3. hack平台hack平台的编译和翻译概览Hack平台的约定 需要有个Main.vm文件；其中一个函数叫main 电脑开启 运行Sys.init Sys.init会call Main.main，然后进入无限循环 约定最开始的两条机器语言指令是：123// 这两行应该卸载hack ROM中，最开始的两行sp=256Call Sys.init 目前为止，VM中的特殊字符一共有如下这么多： 4.具体代码实现还是三个模块Main、Parser和CodeWriter。其中CodeWriter需要增加一些方法，Parser需要补充一些逻辑。 project8: code now! 5.问答因为java先转VM再转机器语言(two tier compiler)，而C++直接转机器语言，因此快（但微软也开发了C++的two tier compiler）java转化为机器语言1000行，C++只需要300行，差不多效率是3倍 **Week3 **","link":"/myBlog/2022/07/10/Nand2Tetris-Part2/"},{"title":"计算机网络-学习笔记","text":"1.1 Internet1.1.1 分层应用层传输层网络层数据链路层物理层 1.1.2 计算机网络路由器是工作在网络层的，交换机是工作在链路层的 网络节点有：1.路由器或交换机等交换设备 2.主机及其运行的程序P2P(Point to Point) 是网络中的一个交换设备到另一个交换设备E2E(End to End) 是网络中每一个终端(PC/手机/Server等)到另一个终端 point在计算机网络中用圆圈表示，End用方块表示 接入链路：终端接入的主干链路：路由器等的链路 1.1.3 协议PDU 协议数据单元在不同的层名字不同，在应用层叫message，在传输层叫segment 从服务角度看计算机网络使用通信设施进行通信的分布式应用由两部分，一部分是应用进程，只认识其他的应用进程。第二部分是基础设施，在应用之下以及负责传输的所有基础设施。 通信基础设施为apps提供编程接口 1.2 网络边缘边缘、核心和接入，三大块上一节中End就是边缘edge，Point是核心core，把pc等边缘设备接入整个网络核心，叫接入access","link":"/myBlog/2022/08/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Fronted","slug":"Fronted","link":"/myBlog/tags/Fronted/"},{"name":"JavaScript","slug":"JavaScript","link":"/myBlog/tags/JavaScript/"},{"name":"React","slug":"React","link":"/myBlog/tags/React/"},{"name":"Coursera","slug":"Coursera","link":"/myBlog/tags/Coursera/"},{"name":"Computer Science","slug":"Computer-Science","link":"/myBlog/tags/Computer-Science/"},{"name":"Mooc","slug":"Mooc","link":"/myBlog/tags/Mooc/"},{"name":"Java","slug":"Java","link":"/myBlog/tags/Java/"},{"name":"Full Stack","slug":"Full-Stack","link":"/myBlog/tags/Full-Stack/"},{"name":"Backend","slug":"Backend","link":"/myBlog/tags/Backend/"},{"name":"OOP","slug":"OOP","link":"/myBlog/tags/OOP/"},{"name":"Network","slug":"Network","link":"/myBlog/tags/Network/"}],"categories":[{"name":"CS网课笔记","slug":"CS网课笔记","link":"/myBlog/categories/CS%E7%BD%91%E8%AF%BE%E7%AC%94%E8%AE%B0/"},{"name":"技术书籍笔记","slug":"技术书籍笔记","link":"/myBlog/categories/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E7%AC%94%E8%AE%B0/"}]}