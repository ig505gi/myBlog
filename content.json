{"pages":[],"posts":[{"title":"JavaScript高级程序设计","text":"Chapter 1-7 JS的基础知识1 JS的历史 JS包括ECMA、DOM、BOM…2 HTML HTML的发展，HTML中如何用JS… 3 语法 Number类型的上下限…4 变量、作用域 执行环境是什么，「没有块级作用域」 垃圾回收、接触引用5 引用类型6 面向对象 设计模式：工厂模式、继承模式 原型链7 私有变量 闭包 模仿块级作用域 模块模式 &amp; 单例模式 Chapter 8 BOM1 window对象 frame框架，每一层都有个window对象，top指向最高层级的window 窗口位置 窗口大小 导航和打开窗口 间歇调用和超时调用(setTimeout/setInterval) 系统对话框(alert/prompt/confirm/print/find)2 location对象 既是windows的对象，又是document的对象 location的属性： 每次修改location的属性(hash除外)页面都会以新url重新加载 replace方法不能生成历史记录，也不能返回刚刚的网页3 navigator对象 有属性浏览器版本信息、名称、插件、环境等 注册处理程序registerContentHandler()和registerProtocolHandler()方法，跟RSS和在线电子邮件有关4 screen对象能够拿到一些屏幕的硬件信息：PPI、像素、刷新率等，对于编程意义不大5 history对象安全的：开发者是不能知道用户访问过那些网页的方法：go/back/forward Chapter 10-12 DOMDOM（文档对象类型）是针对HTML和XML文档的一个API。DOM 可以将任何HTML或XML文档描绘成一个由多层节点构成的结构。节点分为几种不同的类型。如下多种： 1 节点层次1.1 Node类型 其它节点都继承自Node类型，每个节点都有一个nodeType的属性，记录了其类型 每个节点都有这样或那样的关系。每个节点都有一个childNodes属性，其中保存着一个NodeList对象 每个节点都有一个parentNode属性，该属性指向文档树中的父节点 常用方法appendChild()。用于向childNodes列表的末尾添加一个节点。 常用方法insertBefore()。这个方法接受两个参数:要插入的节点和作为参照的节点。 常用方法replaceChild()。这个方法接受两个参数:要插入的节点和要替换的节点。 其他方法cloneNode()可以深浅复制；normalize()处理文档树中的文本节点。1.2 Document类型 document对象是HTMLDocument(继承自Document类型)的一个实例，表示整个HTML页面。 document对象是Window对象的一个属性，可以将其作为全局属性访问。 document对象的属性nodeType值为9。 document对象的属性documentElement、firstChild和childNodes[0]的值相同，都指向&lt;html&gt;元素。 document作为HTMLDocument实例，有一些不同于Document类型的属性：title、URL、domain、referrer。其中title和domain是可以设置的，domain只能修改三级域名(www) Document类型都有的方法：getElementById()和getElementsByTagName();HTMLDocument类型独有的方法是getElementsByName()。 document有一些集合可以方便拿到一些HTMLCollection：document.links拿到所有带href的&lt;a&gt;元素、document.forms拿到所有&lt;form&gt;元素、document.images拿到所有&lt;img&gt;元素 document.implementation.hasFeature(&quot;XML&quot;, &quot;1.0&quot;) 可以检测DOM的功能及版本号 document对象具有输出流写入网页的功能：write()、writeln()、open()、close()1.3 Element类型 所有的HTML元素都是HTMLElement类型，其继承自Element类型，添加了一些Element没有的属性：id、titile、className等；可以直接像这样div.id通过属性访问对其属性赋值和取值 getAttribute()、setAttribute()、removeAttribute()是三个常用的方法 H5规范规定，自定义特性需要有data-前缀；通过getAttribute方法可以拿到自定义特性的值；除了IE可以直接用div.myAttr这样通过属性访问拿到特性的值，其他浏览器都不可以 style属性：通过getAttribute方法拿到的是CSS文本，通过属性访问拿到的是对象 onClick属性：通过getAttribute方法拿到的是响应代码的字符串，通过属性访问拿到的是JS函数 通过setAttribute()方法设置的特性，统一会变成小写 想要遍历元素的特性，可以使用attributes属性element.attributes var div = document.createElement(&quot;div&quot;);1.4 Text类型 文本节点，parentNode是一个Element类型；通过nodeValue属性或data属性访问文本内容，是一致的 常用方法：appendData() deleteData() insertData() replaceData() splitText() substringData() div.firstChild.nodeValue = 'aa&lt;s&gt;'; 输出的结果是转义过的，是aa&amp;lt;s&amp;gt; document.createTextNode()创建新文本节点，但是如果不指定其父元素，在页面上是看不到的； 1.5-1.9 其它类型 Comment类型：parentNode可能是Document或Element类型；有除了splitText以外的Text类型的全部方法 CDATASection：类型只针对基于XML的文档 DocumentType类型：在Web浏览器中并不常用，仅有 Firefox、Safari 和 Opera 支持它 DocumentFragment类型：只有它在文档中没有对应的标记，可以当做一个仓库。比如如果向文档中渲染三个连续的元素，先放到仓库里，可以避免重复渲染三次 Attr类型：不是DOM文档树的一部分，是元素的特性 2 DOM扩展2.1 选择符API querySelector() querySelectorAll() msMatchesSelector() … 3 DOM2和DOM3DOM1主要定义的是HTML和XML文档的底层结构 DOM2的模块 DOM2级核心(DOM Level 2 Core):在1级核心基础上构建，为节点添加了更多方法和属性。 DOM2级视图(DOM Level 2 Views):为文档定义了基于样式信息的不同视图。 DOM2级事件(DOM Level 2 Events):说明了如何使用事件与 DOM 文档交互。 DOM2级样式(DOM Level 2 Style):定义了如何以编程方式来访问和改变 CSS 样式信息。 DOM2级遍历和范围(DOM Level 2 Traversal and Range):引入了遍历 DOM 文档和选择其特定部分的新接口。 DOM2级HTML(DOM Level 2 HTML):在1级HTML基础上构建，添加了更多属性、方法和新接口。 … Chapter 13 事件JS和HTML之间的交互是通过事件实现的。","link":"/myBlog/2022/03/21/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"title":"Effective javascript","text":"chapter1 让自己习惯JavaScript1.ES版本问题及strict modeES5引入了严格模式，使用字符串字面量作为指令是为了向前兼容，ES3看到&quot;use strict&quot;会直接丢掉。为了解决严格模式和非严格模式的文件打包在一起的问题，可以用IIFE(Immmediately Invoked Function Expression)来解决 2.number是浮点型JS中的数字只有number一种类型，是符合IEEE754制定的64位编码数字—-doublesnumber的位运算会隐式地转为32位整数，然后计算。 3. 当心隐式的强制转换很多JS代码不会报错，而是会做强制的转换 123453 + true // 4&quot;hello&quot; + &quot; world&quot; // &quot;hello world&quot;2 + &quot;3&quot; // &quot;23&quot;&quot;17&quot; * &quot;5&quot; // 85&quot;8&quot; | &quot;1&quot; // 9 尽量避免使用valueOf() 3.1 真值运算(truthines)JS有7个假值：false/0/-0/&quot;&quot;/null/NaN/undefined 4.原始类型优于封装对象JS的5个原始类型boolean/number/string/null/undefined 封装对象的方法，原始类型也可以使用，例如toUpperCase是String的原型对象的方法，而原始字符串可以直接调用：&quot;hello&quot;.toUpperCase(); // &quot;HELLO&quot;这种隐式封装，每次调用都会产生一个新的String对象，因此对其设置属性是不起作用的。 5.避免对混合类型使用==运算符当两个参数属于同一类型时，==和===是没有区别的当使用==对不同的类型比较时，有强制类型转换规则，记忆比较麻烦，因此最好避免 6.了解分号插入的局限JS有自动分号插入技术，因此不用写分号。分号插入的规则： 分号仅在}标记之前、一个或多个换行之后和程序输入的结尾被插入 分号仅在随后的输入标记不能解析时插入 7.视字符串为16位的代码单元序列因此，一个以上的音乐符号，在字符串中的长度是2 1234&quot;∮ clef&quot;.charCodeAt(0); // 55348(0xd834)&quot;∮ clef&quot;.charCodeAt(0); // 56606(0xdd1e)&quot;∮ clef&quot;.charAt(1) === &quot; &quot;; // false&quot;∮ clef&quot;.charAt(2) === &quot; &quot;; // true chapter2 变量作用域8.尽量少用全局对象简单理解：容易冲突 9.始终声明局部变量虽然js不声明变量不会报错，但是这个变量直接变成了全局变量，要避免 10.避免使用withwith可以避免对对象的重复引用，但是不可靠性大大增加，避免使用 11.熟练掌握闭包事实1. JS允许你引用在当前函数以外定义的变量事实2. 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量事实3. 闭包可以更新外部的值 原理:JS的函数值在内部存储它们可能会引用的定义在其封闭作用域的变量。 12345678910111213function box() { var val = undefined; return { set: function(newVal) { val = newVal; }, get: function() { return val; }, type: function() { return typeof val; } }}var v = box();b.type(); // &quot;undefined&quot;b.set(98.6);b.get(); // 98.6b.type(); // &quot;number&quot; 这基本就是一个Class了，ES6的Class编译之后好像就是这样？ 12.理解变量声明提升JS不支持块级作用域，而是函数级作用域变量提升： 1234567891011121314151617181920function f() { // ... { // ... var x=/*...*/; // ... } // ...}// 会转化为以下：function f() { var x; // ... { // ... x=/*...*/; // ... } // ...} 异常处理的catch看似块级作用域，但是感觉更像函数，因此是个例外 13.使用立即调用的函数表达式创建局部作用域闭包通过引用而不是值捕获它们的外部变量 好好理解下面三段代码： 12345678910function wrapElements(a) { var result = [], i, n; for(i = 0, n = a.length; i &lt; n; i++) { result[i] = function() { return a[i]; }; } return result;}var wrapped = wrapElements([10, 20, 30]);var f = wrapped[0];f(); // undefined 12345678910function wrapElements(a) { var result = []; for(var i = 0, n = a.length; i &lt; n; i++) { result[i] = function() { return a[i]; }; } return result;}var wrapped = wrapElements([10, 20, 30]);var f = wrapped[0];f(); // undefined 这个版本更具有欺骗性，但是由于变量提升，没有块级作用域，i仍然只有一个槽(slot)想实现的效果： 12345678910111213function wrapElements(a) { var result = [], i, n; for(i = 0, n = a.length; i &lt; n; i++) { (function() { var j = i; result[i] = function() { return a[j]; }; })() } return result;}var wrapped = wrapElements([10, 20, 30]);var f = wrapped[0];f(); // 10 14.当心命名函数表达式笨拙的作用域123456var f = function abs(a) { return a &lt; 0 ? -a : a;}f(-2); // 2abs(-3); // wrong 并没有abs这个变量// 但是有些JS环境会产生abs，甚至分配多余的内存，都是不符合规范的 命名函数表达式的作用域在E3中会表示为一个对象，从而导致跟with语句一样的问题，作用域会受到Object.prototype的属性变化。在E5中修复了这个问题 15.当心局部块函数生命笨拙的作用域函数中可以嵌套函数，但是如果再把函数声明放在if语句块中呢？在不同的JS运行环境中，可能有不同的解释，因此避免使用 16.避免使用eval创建局部变量eval很强大，但使用起来有安全性，避免如下使用方式： 123456function test(src) { eval(src); return y;}test(&quot;var y = 'local';&quot;); 推荐如下，这样不会对函数内部造成影响： 123456function test(src) { (function() {eval(src);})() return y;}test(&quot;var y = 'local';&quot;); 17.间接调用eval函数优于直接调用大多数函数只能访问定义它们所在的作用域，而eval函数具有访问调用它那时的整个作用域的能力。 （有点绕） 直接调用和间接调用： 123456var x = 'global';function test() { var x = 'local'; return eval(&quot;x&quot;); // 直接调用}test(); // &quot;local&quot; 1234567var x = 'global';function test() { var x = 'local'; var f = eval; return f(&quot;x&quot;); // 间接调用}test(); // &quot;local&quot; 例子是有了，但是不太明白为什么后者优于前者 间接调用还有另外一种方式(0, eval)(src) chapter3 使用函数18.理解函数调用、方法调用及构造函数调用在面向对象中，三种概念是不同的。但是在JS中，只是单个构造对象的不同使用模式。方法就是特定对象调用的函数如果纯函数中使用this，会默认使用全局对象，但ES5中规定的严格模式不会这么做，会报错。纯函数作为构造函数使用： 12345678function User(name, age) { this.name = name; this.age = age;}// 用new操作符能识别构造函数const person = new User('Jack', 18);person.name; // 'Jack' 19. 熟练掌握高阶函数 高阶函数是那些将函数作为参数或返回值的函数 熟悉掌握现有库中的高阶函数 学会发现可以被高阶函数所取代的常见的编码模式 20. 使用call方法来自定义接收者来调用方法需要自定义接收者来调用函数时，也就是说想改变函数中的this 12345// 不推荐的方法：obj.temp = f;f(arg1, arg2);delete obj.temp// 万一obj就有temp呢？ call方法支持传入一个接收者来调用函数，相当于改变了this 21. 使用apply方法通过不同数量的参数调用函数当一个函数可接受可变参数时，用apply传入数组 123var scores = getAllScores(); // 返回一个数组// average可接受可变参数average.apply(null, scores); 22. 使用arguments创建可变参数的函数如果提供一个便利的可变参数的函数，同时最好提供一个需要显式指定数组的固定参数版本，很容易实现： 1234function average() { // average可接受可变参数 averageOfArray(arguments);} 23. 永远不要修改arguments对象如下实现： 12345678910function callMethod(obj, method) { var args = [].slice.call(arguments, 2); retrun obj[method].apply(obj, args);}var obj = { add: function(x + y) { return x + y; }}callMethod(obj, 'add', 17, 25); 24.使用变量保存arguments对象的引用主要是注意函数嵌套时，arguments会变，要用外层的arguments时，需要先保存引用 25.使用bind方法提取具有确定接收者的方法12345678910111213141516var buffer = { entries: [], add: function(s) { this.entries.push(s); }}// wrongvar source = [1, 2, 3];source.forEach(buffer.add); // entries undefined// correctsource.forEach(buffer.add.bind(buffer));// 注意！！buffer.add === buffer.add.bind(buffer); // false bind是安全的，不会修改add方法，bind方法创建了一个新的方法，里面this指向的buffer 26.使用bind函数进行函数柯里化1234567891011function simpleURL(protocol, domain, path) { return protocol + '://' + domin + '/' + path;}//优化前var urls = paths.map(function(path) { return simpleURL('http', siteDomain, path);})// 优化后var urls = paths.map(simpleURL.bind(null, 'http', siteDomain)); 27.使用闭包而不是字符串封装代码这个正常人也不会用eval… 28.不要信赖函数对象的toString()方法如题，因为在不同JS引擎中结果不同 29.避免使用非标准的栈检查工具arguments.caller虽然能告诉你函数的调用者，如果用它来实现栈检查工具，在函数调用本身的情况下，会陷入无限循环 Chapter4 对象和原型虽然JS支持继承，但不像传统语言，继承不是基于类，而是基于原型。 30.31.32.prototype/getPrototypeOf()/__proto__它们是对立但相关的访问器 C.prototype用于建立由new C()c创建的对象的原型 Object.getPrototypeOf(obj)是ES5中用来获取obj对象的原型对象的标准方法 obj.__proto__是获取obj对象的原型对象的非标准方法 因此，尽量用getPrototypeof(),尽量不去修改__proto__ 33.使构造函数与New操作符无关如果不使用new而是直接： 1var u = User('Jack', '18'); 如果内部用了严格模式，并给this.name赋值，会报错所以内部函数要考虑到这种情况，判断this是否是undefined，主动new一个 34. 在原型中储存方法如果在对象中储存方法，每个实例都会生成副本，而在原型中，只有一个 35. 闭包存储私有变量对象中的属性很容易通过this获取，如果有私有变量可以利用闭包存储 12345678function User(name, passwordHash) { this.toString = function() { return 'User ' + name; }; this.checkPassword = function(password) { return Hash(password) === passwordHash; }} 但是会牺牲一些，如34的问题，不能将该方法存在原型中。 36. 只将实例状态保存在实例对象中别保存在原型中，不然所有实例会共享，显而易见 37. this变量的隐式绑定问题经常遇到，this的作用域是由最近的封闭函数确定，解决该办法有三种方法 arr.map((v) =&gt; this.outerFunc(v), this) 有很多函数接受第二个参数绑定this var self = this; arr.map(... 在外部把this保存一下 arr.map((v) =&gt; this.outerFunc(v).bind(this)) 使用bind 38. 在子类中的构造函数调用父类的构造函数假设飞船SpaceShip是游戏中Actor的子类， 1234function SpaceShip(scene, x, y) { Actor.call(this, scene, x, y); this.point = 0;} 先调用Actor的构造函数，使Actor的实例属性添加到新对象中后续作为一个正确的子类，SpaceShip的原型必须继承Actor.prototype 12345// ✔️rightSpaceShip.prototype = Object.create(Actor.prototype);// ❌ wrongSpaceShip.prototype = new Actor(); 上述正确做法避免调用了Actor的构造函数。 39.不要重用父类的属性名如题 理解很简单 40.避免继承标准类如果继承标准类，其行为会被特殊的内部标记属性[[Class]]破坏如果child继承了array，child是object，不会有array的行为 41.将原型视为实现细节对象是接口，原型是实现 (？如何理解) 42.避免使用轻率的猴子补丁猴子补丁是指，假如Array缺少一个split方法，那么直接Array.prototype.split = ...创建一个方法。。 如果非要用，可以考虑封装在一个function中，调用给函数的代码才会修改原型 Chapter5 数组和字典43.使用Object的直接实例构造轻量级字典其实就是常用的做法，把一个Object直接当成字典来用但是文中指出了避免对其原型上增加方法，不然会导致错误(原型污染) 44.使用null原型防止原型污染用Object.create(null)创建空对象，不容易被污染（？）还是会在属性查找的时候，出现污染现象 45.使用hasOwnProperty避免原型污染这样不会拿到加在原型上的方法更严谨的：你不知道对象上的hasOwnProperty是否被覆盖了，可以这么办 12var hasOwn ={}.hasOwnProperty;hasOwn.call(obj, 'Alice'); 46.使用数组而不要使用字典来储存有序集合很简单明了，对象的key是无序的 47.绝不要在Object.prototype中增加可枚举的属性如果想增加方法给原型，会污染for…in方法，以下方式可以解决这个问题： 123456789101112Object.defineProperty(Object.prototype, 'allKeys', { value: function() { var result = []; for (var key in this) { result.push(key); } return result; }, writable: true, enumerable: false, configurable: true}) 48.避免在枚举之间修改对象 使用for…in的时候一定不要修改可枚举对象，会出现意外情况。 可改用for循环或者while 为了在一个可变的枚举对象中遍历，可以考虑再用一个额外的数组去保存信息 49.数组迭代优先使用for循环而不是for…in1234567var scores = [98, 74, 85, 77, 93, 100, 89];var total = 0;for(var score in scores) { total += score;}var mean = total / scores.length;mean; // ? 第一层❌：以上代码看似求平均值，得出88；第二层❌：for…in拿的是index，所以是0+1+2。。。total=21,mean=3;实际✔️：for…in拿的确实是index，但是是string，所以得到了total=’0123456’, 强制类型转化为了123456/7,得到17636.57…. 解决：用普通for循环即可 12// 更好的代码for(var i = 0, n = scores.length; i &lt; n; i++) {...} 提前计算出n，避免长度变化的影响 50.迭代方法优于循环 因为自己写for循环很容易写错初始条件，尽量用数组的forEach,map,filter,every,some等迭代方法。 同样的，对自己定义的抽象对象，也可以尽量实现迭代方法去遍历。 51.在类数组对象中复用数组方法举个例子： 12345function highlight() { [].forEach.call(arguments, function(widget){ widget.setBackground('yellow'); });} 像arguments、DOM中的Nodelist，都没有继承JS的Array原型，但是是类数组 类数组定义：这个例子不满足第二条：var arraylike = {0: 'a', 1: 'b', length: 2}因为，length不能自动变化 但是Array的几乎所有方法和length变化无关，因此arraylike可以用，除了concat 52.数组字面量优于数组构造函数使用这种字面量语法：var list = [1, 2, 3]优于这种构造函数语法：var list = new Array(1, 2, 3) 因为Array可能有人修改，可能有人包装过。。。(说得有道理，但是不常见) Chapter6 库和API设计53.保持一致的约定 变量命名和函数签名尽量一致 参数顺序尽量一致，比如先宽度，后高度 优秀的库都有完善的文档，如果文档保持一致，用户面对一些常见的任务就不用不停得看文档 54.将undefined看作“没有值” 避免使用undefined表示某一非特定值 不要用undefined表示特定标志 提供的默认参数用undefined检查，而不是arguments.length 在允许0、NaN、’’存在的情况，避免用真值测试(width || 300) 55.接受关键字参数的选项对象多参数虽然简单，但参数多的时候难以记忆:new Person(18, 'Bob')选项对象，不用记忆顺序：new Person({age: 18, name: 'Bob'}) 用选项对象使API可读性提高，减少记忆 一般所有的选项对象都是可选的 用extend函数(lodash.merge也可以吧？)抽象从选项对象中取值的逻辑 56.避免不必要的状态函数内部不保存状态，输入参数相同时，输出也相同。个人理解也就是纯函数。更加模块化、减少不同部分的影响、使代码更易于阅读。一个著名的有状态的API是Web的Canvas库，一开始学的时候确实费劲。。 57.使用结构类型设计灵活的接口举个例子，以下代码是我们将实现的功能： 1234567891011121314// Wiki.formats.MEDIAWIKI为格式化器var app = new Wiki(Wiki.formats.MEDIAWIKI);// Wiki将格式化函数存储在了wiki实例对象的内部function Wiki(format) { this.format = format;}// 每次渲染页面时，会调用Wiki的displayPage方法，内部实现如下：Wiki.prototype.displayPage = function(source) { var page = this.format(source); var title = page.getTitle(); var author = page.getAuthor(); var output = page.toHTML(); // ...} 方法一：使用类去实现格式化器创建一个Page基类，再实现一个继承Page的MWPage类(其他格式也都为Page的子类)，然后MEDIAWIKI则是一个返回MWPage实例的一个“工厂函数”，代码如下： 123456789101112131415function MWPage(source) { Page.call(this, source); // ...}// MWPage extends PageMWPage.prototype = Object.create(Page.prototype);MWPage.prototype.getTitle = /* ... */;MWPage.prototype.getAuthor = /* ... */;MWPage.prototype.toHTML = /* ... */;Wiki.formats.MEDIAWIKI = function(source) { return new MWPage(source);} 确实是OOP的做法，但问题是调用的3个方法都是自己实现的，并未从Page继承任何有用的代码。 方法二：结构类型12345678Wiki.formats.MEDIAWIKI = function(source) { // ... return { getTitle: function() { /* ... */ }, getAuthor: function() { /* ... */ }, toHTML: function() { /* ... */ }, };}; 只要displayPage方法结构正确，具有预期的getTitle、getAuthor、toHTML方法，那么这个格式化器就OK；比PAGE类更加灵活。 这种接口有时候称为结构类型或鸭子类型，优雅的轻量的编程模式。 58.区分数组对象和类数组对象有这么一个方法，支持入参为 一个数组或一个对象，也就是实现了方法的重载。那么就必须在方法内部去判断这个入参是数组还是对象，这时候就要考虑类数组的概念了（51条），类数组是一个对象但是可以被视为数组，所以如何区分？因此引出了如下规则： API绝不应该重载与其他类型有重叠的类型不完美的方案：if (x instanceof Array)。跨frame通信时，会有多个Array的原型副本，是不同的。更好的方案：if (Array.isArray(x))。 59.避免过度的强制转换如题所示，本人几乎不去用强制类型转换。 避免强制类转换和重载的混用 考虑防御性地监视非预期的输入(对入参进行类型判断)如果用TS多了，这种问题基本上不会有。。 60.支持方法链无状态的API的好的例子：String的replace方法、Array的map、filter方法。有状态的API也值得支持，在更新对象时返回this。 123element.setBackgroundColor(&quot;yellow&quot;) .setColor(&quot;red&quot;) .setFontWeight(&quot;bold&quot;); Chapter7 并发61.不要阻塞I/O事件队列 主要是用异步函数和回调去避免阻塞。 JavaScript并发地接收事件，但会使用一个事件队列按序地处理程序 最重要的原则：绝不要在应用程序事件队列中使用阻塞I/O的API 62.在异步序列中使用嵌套或命名的回调函数 使用嵌套或者命名的回调函数按顺序地执行多个异步操作。（合理的处理回调地狱。。） 尝试在过多的嵌套的回调函数和尴尬的命名的非嵌套回调函数之间取得平衡。 避免将可被并行执行的操作顺序化 63.当心丢弃错误 写共享的错误处理函数来避免复制和粘贴错误处理代码 确保异步操作的所有错误情况都处理了，避免丢弃错误 64.对异步循环使用递归想要实现的效果：一个文件下载完，继续下另一个，但给的是一个urls。 12345678910111213function downloadOneAsync(urls, onsuccess, onfailure) { var n = urls.length; function tryNextURL(i) { if (i &gt;= n) { onfailure(&quot;all downloads failed&quot;); return; } downloadAsync(urls[i], onsuccess, function() { tryNextURL(i + 1); }); } tryNextURL(0);} 循环不能异步 使用递归在时间循环的单独轮次中执行迭代 在回调函数中执行递归，不会导致栈溢出 65.不要在计算时阻塞事件队列JS代码在进行长时间计算时，会使web页面无响应。 方案1：Worker API有一个技术可以解决Web平台的Worker API，以下场景，比如一个要搜索大量可移动距离的人工智能游戏，如果在单线程环境下，会卡顿无响应。 123456789101112131415// main.js// 产生一个新的线程独立的事件队列的并发执行线程。var ai = new Worker(&quot;ai.js&quot;);// 主线程需要ai的数据时，通过postMessage的方式交互var userMove = /* ... */;// 需要重新计算用户移动ai.postMessage(JSON.stringify({ userMove: userMove}));// 处理worker线程的响应ai.onMessage = function(event) { excuteMove(JSON.parse(event.data).computerMove);} AI的代码 1234567891011self.onMessage = function(event) { var userMove = JSON.parse(event.data).userMove; var computerMove = computeNextMove(userMove); self.postMessage(JSON.stringify({ computerMove: computerMove })); function computeNextMove(userMove) { // ... }} 方案2：分解算法。组成可管理的工作块搜索社交网络图的算法，改造前的算法while循环代价过高，会阻塞。如果用方案1，还要复制整个网络图的状态或在worker中存储网络图的状态，传递消息来更新和查询网络。 1234567891011121314151617181920212223242526272829303132333435// 改造前Member.prototype.inNetwork = function(other) { var visited = {}; var worklist = [this]; while (worklist.length &gt; 0) { var member = worklist.pop(); // ... if (member === other) { // found return true } // ... } return false}// 改造后Member.prototype.inNetwork = function(other, callback) { var visited ={}; var worklist = [this]; function next() { if (worklist.length === 0) { callback(false); return; } var member = worklist.pop(); // ... if (member === other) { // found callback(true); return; } // ... setTimeout(next, 0); // schedule the next iteration } setTimeout(next, 0); // schedule the first iteration} 利用回调函数拿到异步查询的结果，查询过程中不会阻塞。但如果在一个应用程序事件队列中只执行算法的一个迭代，有点杀鸡用牛刀，可以稍微调整下，在next函数中加一个循环，每进行10次循环再setTimeout(next, 0) 66.使用计数器来执行并行操作并行发生的事件，回调函数的执行顺序是未知的，注意返回结果的顺序。解决：用数组的index去保存结果(JS不会报index出边界的错误。。)，用计数器保证所有成功的时候回调。 12345678910111213141516171819202122232425function downloadAllAsync(urls, onsuccess, onerror) { var pending = urls.length; var results = []; if (pending === 0) { setTimeout(onsuccess.bind(null, result), 0); return; } urls.forEach(function(url, i) { downloadAsync(url, function(text) { if (result) { result[i] = text; pending--; if (pending === 0) { onsuccess(result); } } }, function(error) { if (result) { result = null; onerror(error); } }) });} 67.绝不要同步地调用异步的回调函数 即使可以立即得到数据，也绝不要同步地调用异步回调函数。 同步地调用异步的回调函数扰乱了预期的操作序列，并可能导致意想不到的交错代码。 同步地调用异步回调函数可能导致栈溢出或错误地处理异常 使用异步的API，比如setTimeout去调度异步回调函数 68.使用promise模式清洁异步逻辑promise经常用，就不细说了 promise代表最终值，即并行操作完成时最终产生的结果 使用promise组合不同的并行操作 使用promise模式的API避免数据竞争 在要求有意的竞争条件时使用select(早期的API吧，后期有race)","link":"/myBlog/2021/05/15/Effective-javascript/"},{"title":"深入React技术栈-Chapter3-React源码","text":"1. 初探React源码React源码的组织结构 而renderers目录结构是这样的 client是客户端操作dom的一些方法；server是服务端渲染的实现和方法；event包含有一套自定义的事件插件系统；作为React核心的reconciler，称为协调器，管理组件的实现、生命周期、setState、DOM diff算法;管理Virtual DOM 2. Virtual DOM 模型ReactNodeVirtual DOM的节点叫作ReactNode 12type ReactNode = ReactElement | ReactFragment | ReactText;type ReactElement = ReactComponentElement | ReactDOMElement; // 差一些 ReactDOMComponent 属性的更新，包括更新样式、更新属性、处理事件等; 子节点的更新，包括更新内容、更新子节点，此部分涉及diff算法。 // 差很多","link":"/myBlog/2022/02/21/%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88-Chapter3-React%E6%BA%90%E7%A0%81/"},{"title":"深入React技术栈-Chapter1-2","text":"1.React基础React生命周期 无状态组件 无状态组件挂载时只是函数的调用，没有创建实例。 因此findDOMNode和refs都不能用，同时建议，这两个方法尽量别用，会打破封装性。 在能用无状态组件的情况下，尽量用无状态组件 React之外的DOM操作尽量不用DOM操作为了保证封装性，但有时有一些操作没办法避免 H5的video的play和input的forcus 点击其他区域合上该组件 计算DOM的尺寸自己的理解：用hooks解决以上2，3问题，保证了一定的封装性？ 2.事件合成事件的实现机制事件委派和自动绑定 事件委派：有一个统一的事件监听层，并不会把事件处理函数直接绑定到真实的节点上。 自动绑定：React组件中，每个方法的上下文都会指向该组件的实例，即this自动指向当前组件。 三种手动绑定方法如果用ES6 classes或者纯函数，就没自动绑定了，需要手动绑定： 1.bind方法绑定 1return &lt;button onClick={this.handleClick.bind(this, 'tes')}&gt;Test&lt;/button&gt; 2.构造器内声明class中的方法不用箭头函数，就必须绑定 1234567// 在constructor中：this.handleClick = this.handleClick.bind(this);// 在 class中handleClick(e) { ...} 3.箭头函数如果使用箭头函数，可以直接这样： 12345678class App extends Component { const handleClick = (e) =&gt; { console.log(e); } render() { return &lt;button onClick={this.handleClick}&gt;Test&lt;/button&gt; }} React合成事件的限制React 的合成事件系统只是原生 DOM 事件系统的一个子集。它仅仅实现了 DOM Level 3 的事件接口，并且统一了浏览器间的兼容问题。有些事件 React 并没有实现，或者受某些 限制没办法去实现，比如 window 的 resize 事件 React合成事件和JS原生事件的对比1. 事件传播与阻止事件传播原生DOM事件三阶段：1.事件捕获 2.事件处理 3.事件冒泡 而React没有实现事件捕获，因为其在开发中意义不大 (?) 2.事件类型React 合成事件的事件类型是 JavaScript 原生事件类型的一个子集 3.事件绑定方式不多说了 4.事件对象原生 DOM 事件对象在 W3C 标准和 IE 标准下存在着差异。在低版本的 IE 浏览器中，只能使用 window.event 来获取事件对象。而在 React 合成事件系统中，不存在这种兼容性问题，在事件处理函数中可以得到一个合成事件对象。 3.表单受控组件React 受控组件更新 state 的流程: (1) 可以通过在初始 state 中设置表单的默认值。 (2) 每当表单的值发生变化时，调用 onChange 事件处理器。 (3) 事件处理器通过合成事件对象 e 拿到改变后的状态，并更新应用的 state。 (4) setState 触发视图的重新渲染，完成表单组件值的更新。 4.CSSCSS模块化CSS模块化的问题 全局污染:CSS 使用全局选择器机制来设置样式，优点是方便重写样式。缺点是所有的 样式都是全局生效，样式可能被错误覆盖，因此产生了非常丑陋的 !important，甚至 inline !important 和复杂的选择器权重计数表1 ，提高犯错概率和使用成本。Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它把样式彻底局部化，造成 外部无法重写样式，损失了灵活性。 命名混乱:由于全局污染的问题，多人协同开发时为了避免样式冲突，选择器越来越复 杂，容易形成不同的命名风格，很难统一。样式变多后，命名将更加混乱。 依赖管理不彻底:组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样 式。现在的做法是除了要引入 JavaScript，还要再引入它的 CSS，而且 Saas/Less 很难实现 对每个组件都编译出单独的 CSS，引入所有模块的 CSS 又造成浪费。JavaScript 的模块化 已经非常成熟，如果能让 JavaScript 来管理 CSS 依赖是很好的解决办法，而 webpack 的 css-loader 提供了这种能力。 无法共享变量:复杂组件要使用 JavaScript 和 CSS 来共同处理样式，就会造成有些变量 在 JavaScript 和 CSS 中冗余，而预编译语言不能提供跨 JavaScript 和 CSS 共享变量的这种 能力。 代码压缩不彻底:由于移动端网络的不确定性，现代工程项目对 CSS 压缩的要求已经到 了变态的程度。很多压缩工具为了节省一个字节,会把 16px 转成 1pc，但是这对非常长的 类名却无能为力 CSS与JS变量共享12345/* config.scss */ $primary-color: #f40;:export { primaryColor: $primary-color;} 1234/* app.js */import style from 'config.scss';// 会输出 #F40 console.log(style.primaryColor); css Modules使用技巧 不适用选择器，只用class名来定义样式 不层叠多个class，只用一个class把所有样式定义好 通过composes组合来实现复用 不嵌套 如果在style文件中使用id选择器、伪类和标签选择器，不会被转换或者加前缀 react-css-modules库可以避免重复输入styles.** 1234567891011121314151617181920import React, { Component } from 'react';import classNames from 'classnames';import CSSModules from 'react-css-modules';import styles from './dialog.css';class Dialog extends Component { render() { const cx = classNames({ confirm: !this.state.disabled, disabledConfirm: this.state.disabled, }); return ( &lt;div styleName=&quot;root&quot;&gt; &lt;a styleName={cx}&gt;Confirm&lt;/a&gt; // ... &lt;/div&gt; ); }}export default CSSModules(Dialog, styles); 使用 CSS Modules，容易使用 :global 去解决特殊情况，使用 react-css-modules 可写成 ，这种形式轻松对应全局和局部; 5.React组件组件通信 父向子通信：属性 子向父通信：回调 跨级通信：在父组件中定义ChildContext,子组件可以直接用this.context拿到对应的值；context可以存在很多级 无嵌套关系通信：使用Events模块的事件订阅和发布来实现 组件间抽象mixinJS中的mixinmixin是为了弥补一些老的OOP语言不能实现多重继承的缺点，而采用的另外一个方法 1// TODO 有空自己实现一下 React中的mixin 适用于createClass的情况。。比较老了，不再细讲 使用ES6 Classes和decorator，用法：123456789101112import React, { Component } from 'React';import { mixin } from 'core-decorators';const PureRender = { shouldComponentUpdate() {}};const Theme = { setTheme() {}};@mixin(PureRender, Theme)class MyComponent extends Component { render() {} } 但是mixin也有命名冲突、破坏原组件的封装性等问题 高阶组件解释：React组件被包裹，高阶组件会返回一个增强的React组件。实现高阶组件有两种方式：属性代理和反向继承 属性代理1234567import React, { Component } from 'React';const MyContainer = (WrappedComponent) =&gt; class extends Component { render() { return &lt;WrappedComponent {...this.props} /&gt;; } } 当然，也可以使用装饰器语法。调用顺序didmount→HOC didmount→(HOCs didmount)→(HOCs will unmount)→HOC will unmount→unmount 反向继承123456const MyContainer = (WrappedComponent) =&gt; class extends WrappedComponent { render() { return super.render(); } } 特点：渲染劫持，控制state(大部分高阶组件都应该限制读取或增加state，防止混乱) 组合式组件组合式的方式意图打破这种关联，寻求单元化，通过颗粒度更细的 基础组件与抽象组件共有交互与业务逻辑的高阶组件，使组件更灵活，更易扩展，也使我们能够 完成对于基础组件的自由支配。 组件性能优化纯函数的定义 给定相同的输入，总返回相同的输出 过程没有副作用 没有额外的状态依赖理解：1.好理解。2.入参有个对象，函数内是该对象的引用，对其进行改变，就是所谓的产生了副作用。可以用immutable的概念去解决，用lodash的cloneDeep。3.在方法内不使用共享变量，内部所有变量只在方法的生命周期内存活，拒绝闭包？ PureRender重新实现shouldComponentUpdate方法，对props和state做浅比较，值对比引用(深比较实在太昂贵了)以下类型，无论如何都会触发pureRender的重渲染： props直接设置为对象或数组1&lt;Account style={{color: 'black'}} /&gt; 因为每次都是重新生成了一个新对象，数组同理；解决：先定义一个变量即可。 设置props方法并通过事件绑定在元素上1&lt;input onChange={this.handleChange.bind(this)} /&gt; 每次会重新生成新函数对象(箭头函数也同理？)。解决：bind放在constructor内 设置子组件12345678&lt;Item&gt; &lt;span&gt;Arcthur&lt;/span&gt;&lt;Item/&gt;// 翻译后 每次都生成了新对象&lt;Itemchildren={React.createElement('span', {}, 'Arcthur')}/&gt; 解决：使用Item组件的父组件也要pureRender Immutable引用赋值的问题：容易改变，复杂系统有隐患。深拷贝：浪费内存 Immutable DataImmutable Data被创建后，不能更改。如果对原数据修改，会生成一个新的Immutable对象。Immutable.js库就是这样的理念 Immutable的优点复杂度降低；节省了内存，因为节点是共享的；重做/撤销、复制/粘贴都可以实现，老数据都存着呢；并发安全，对于JS来说好像无关紧要，单线程。。；拥抱函数式编程，其本就是函数式编程的概念。 缺点api还是和原生map array有区别 Immutable 与 PureRender用immutable的is去改造shouldComponentUpdate即可 keyArray&lt;Element&gt;渲染时，每一个item都要唯一的key，切不建议使用index，建议使用id或shortid 性能检测工具react-addons-perf使用Perf.start()和Perf.stop()分析 6.动画后续添加 7.自动化测试后续添加","link":"/myBlog/2021/11/29/%E6%B7%B1%E5%85%A5React%E6%8A%80%E6%9C%AF%E6%A0%88-Chapter1-2/"},{"title":"Nand2Tetris Part1","text":"从一个门电路开始，搭建一台电脑。课程地址：https://www.coursera.org/learn/build-a-computer作业repo：https://github.com/ig505gi/Nand2Tetris-homework Week1 布尔运算和逻辑门1.1 运算法则 1.2 NAND任何一个布尔函数都可以用只含有AND和NOT操作符的表达式来表示；而NAND是NOT和AND的结合，因此：任何一个布尔函数都可以用只含有NAND操作符的表达式来表示 1.3 XORps: HDL: Hardware Design Language 1.4 Multiplexor和DemultiplexorHDL中的subBuses：Multiplexor非常有用，可以从多条数据中选出其中的一条Demultiplexor可以从一条数据中按照规律解析成多条数据 Week2 加法和算术逻辑单元ALU2.1 半加器和加法器半加器真值表： 输入输出 a b sum carry 值 0 0 0 0 值 0 1 1 0 值 1 0 1 0 值 1 1 0 1 全加器真值表和接口 2.2 负数和补位从左起第一位为0的为正数，为1的为负数，x+(-x)=0，如果不考虑进了一位，也就是2^n 2.3 ALUCPU里的核心计算单元，该项目里设计的比较简单 Week3 内存3.1 Sequential Logic &amp; DFF序列逻辑可以在一个位置存放所有的信息(这句怎么理解？)DFF: Data Filp Flop特点：1.自己需要保存一个状态，2.该状态取决于上一个时间unit的输入 3.2 Register寄存器1-Bit Register内部用一个DFF和一个Mux可以实现。16个1-Bit Register组合在一起成为一个16位寄存器 3.3 RAMRegister堆在一起组成RAM，图中的小三角代表是一个Sequential chip读：设置address为i就好写：设置address为i，in为v，load为1 RAM16K我们的电脑内存是16K的，如何用HDL来写？首先实现RAM8.png，tips:8个16bit-Register组成RAM8,8个RAM8组成RAM64。。。。。 3.4 Counter计数器，内部用DFF实现，每过一个时间单位，能自动加一 Week4 机器语言4.1 Machine Language Overview一门机器语言应该有哪些成分？操作符，逻辑运算，流程控制，寻址功能，IO。 如果硬件复杂，可以实现乘除法，机器语言可以包含乘除法，如果硬件简单，可以只有加法； 同样，如果硬件复杂，可以设计负数，浮点型数据类型。如果硬件简单，只有正数 ps: 这里强调tradeoff，一些功能到底设计在硬件层面还是软件层面，由设计者决定。 4.2 Hack ComputerHack电脑认识的机器语言叫Hack语言，由两位教授设计的。 硬件 软件 控制和寄存器 ROM中加载了Hack语言 reset按钮一按，程序开始执行 三个寄存器用来实现Hack语言：A M D，目前先不用管CPU里如何设计，第五章会讲 4.3 Hack Language汇编语言时人能看懂的语言，转化成二进制才是机器认识的机器语言Hack语言含有A命令和C命令 A命令 C命令 4.3 IO屏幕RAM中有一块专门管屏幕的内存screen memory map，hack电脑用512X256像素的黑白屏 键盘RAM中有一个16bit-Register管键盘 4.4 Hack program如果程序不终止，有人在ROM后面写入了恶意命令，就会被执行。如何终止程序：写一个无限循环即可 123// line 6@60;JMP 内置标识符为了方便编程，内置了一些标识符 分支使语言更具有可读性，一般为大写字母 变量也是更具有可读性，不用在其他地方声明，一般为小写字母，而分支需要在其他地方声明 迭代用以上功能实现迭代的功能 指针A寄存器实际上就是一个指针的功能 Week5 电脑架构5.1 整体架构图 5.2 CPU内部具体实现非常优雅，值得细品 Week6 汇编器Assembler用汇编器将汇编语言变成机器语言，可以用高等语言去写，前提是有其他电脑被造出来了。如果没有电脑，只能手工去费时费力的去转化。 汇编器的架构：","link":"/myBlog/2022/06/18/Nand2Tetris-Part1/"}],"tags":[{"name":"Fronted","slug":"Fronted","link":"/myBlog/tags/Fronted/"},{"name":"JavaScript","slug":"JavaScript","link":"/myBlog/tags/JavaScript/"},{"name":"React","slug":"React","link":"/myBlog/tags/React/"},{"name":"Coursera","slug":"Coursera","link":"/myBlog/tags/Coursera/"},{"name":"Computer Science","slug":"Computer-Science","link":"/myBlog/tags/Computer-Science/"}],"categories":[]}